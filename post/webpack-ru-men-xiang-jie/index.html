<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>胡新敏的个人博客</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="胡新敏的个人博客"/>
<meta name="keywords" content="胡新敏的个人博客"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://huxinmin.github.io/favicon.ico">

<link rel="stylesheet" href="https://huxinmin.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://huxinmin.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://huxinmin.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://huxinmin.github.io/images/avatar.png" alt="胡新敏的个人博客"
                 class="img-responsive">
        </figure>
        <a href="https://huxinmin.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>胡新敏的个人博客</h2>
        <p>胡新敏的个人博客</p>
        <ul class="fh5co-social">
            
                <li>
                    
                        <a href="https://github.com/huxinmin" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                        <a href="https://www.zhihu.com/people/hu-xin-min-99" target="_blank">
                            <i class="fab fa-zhihu"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://huxinmin.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://huxinmin.github.io/tag/mSeB0wbbH/">linux</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/0CEgc5Nuc/">react</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/7tyyR9fOk/">ja</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/AzH6zVqFK/">js</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/UJq-iLfq6/">restful</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/r0zynGCMV/">http</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/GNbObqsVG/">json</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/dZU9srOJ4/">moment.js</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/wsD4ABEPz/">数据库</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/tq8jF2xcA/">mongoose</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/VL5yScL71/">mongodb</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/XRK7arMJO/">nodejs</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/DJMLUSVfi/">html5</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/oHlYLx_Tl/">websocket</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/8-tAS0eFO/">nginx</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/X3jlBk5nJ/">css</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/H8XsrzQ7e/">css3</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/J27JVlP2F/">文件上传</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/X3Z7s8kF_/">jquery</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/CrwH886ky/">ajax</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/s0bxFP3uF/">express</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/ZSDYSDwY2/">其他</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/4OX23_HC0/">jest</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/JavlGTiRY/">editorconfig</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/pTofQIx8N/">待办事宜</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/8u7cjaUBn/">随笔</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/knySerdH-/">git</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/NSyjPJZkv/">aws</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/pU8c2aJR5/">webassembly</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/UsaB01y9b/">sublime</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/oVWhBDgSF/">centos</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/JqHVZntTk/">putty</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/HOjS4qCUx/">npm</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            标签
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            关于
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://huxinmin.github.io">胡新敏的个人博客 </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
                    <img src="https://huxinmin.github.io/post-images/webpack-ru-men-xiang-jie.png" alt="Webpack入门详解" class="img-responsive">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
            </span>
            <h2 class="fh5co-article-title animate-box">Webpack入门详解</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2020-04-20</li>
                <li>4526字</li>
                <li>19 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <h2 id="webpack简介">Webpack简介</h2>
<p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p>
<h2 id="why-webpack">Why Webpack?</h2>
<p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>
<ul>
<li>模块化，让我们可以把复杂的程序细化为小的文件;</li>
<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的-<br>
JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；</li>
<li>Scss，less等CSS预处理器</li>
<li>...</li>
</ul>
<p>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。</p>
<h2 id="webpack与gulp以及grunt的对比区别">Webpack与gulp以及grunt的对比区别</h2>
<ul>
<li>Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案</li>
<li>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务</li>
<li>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>
<h4 id="入口">入口</h4>
<ul>
<li>含义：入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的</li>
<li>用法：<pre><code class="language-js">entry: './path/to/my/entry/file.js'
//也可以这样写
entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
}
</code></pre>
</li>
</ul>
</li>
<li>
<h4 id="出口">出口</h4>
<ul>
<li>含义：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件</li>
<li>用法：<pre><code class="language-js">output: {
    filename: '[name].js',
    path: __dirname + '/dist',
    publicPath: &quot;/assets/&quot;
}
</code></pre>
</li>
</ul>
</li>
<li>
<h4 id="loader">Loader</h4>
<ul>
<li>含义：loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理</li>
<li>用法<pre><code class="language-js">module: {
rules: [{
    test: /\.css$/,
    use: [{ loader: 'style-loader' },
          {
            loader: 'css-loader',
            options: {
                modules: true
            }
          }
         ]
    }]
}
</code></pre>
</li>
</ul>
</li>
<li>
<h4 id="插件">插件</h4>
<ul>
<li>含义：loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务</li>
<li>用法：<pre><code class="language-js">  plugins: [
     new webpack.optimize.UglifyJsPlugin(),
     new HtmlWebpackPlugin({template: './src/index.html'})
  ]
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="开始使用">开始使用</h2>
<ul>
<li>
<h4 id="创建packagejson">创建<code>package.json</code></h4>
</li>
</ul>
<p>在终端中使用<code>npm init</code>命令可以自动创建这个<code>package.json</code>文件</p>
<ul>
<li>
<h4 id="安装">安装</h4>
</li>
</ul>
<pre><code class="language-sh"># 全局安装
npm install -g webpack
# 安装到你的项目目录
npm install --save-dev webpack
npm install --save-dev webpack-dev-server
</code></pre>
<ul>
<li>
<h4 id="设置npm-script">设置<code>npm script</code></h4>
</li>
</ul>
<p>在<code>package.json</code>里面编写：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;start&quot;: &quot;webpack&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;,
    &quot;build&quot;: &quot;set NODE_ENV=production &amp;&amp; webpack --config ./webpack.production.config.js --progress&quot;
}
</code></pre>
<p>不是windows系统build只需这样配置即可:</p>
<pre><code class="language-json">&quot;build&quot;: &quot;NODE_ENV=production webpack --config ./webpack.production.config.js --progress&quot;
</code></pre>
<p>然后就可以在终端使用命令进行调用了：</p>
<pre><code class="language-sh">npm run start
npm run dev
npm run build
</code></pre>
<h2 id="配置文件">配置文件</h2>
<p>Webpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如前面提到的，这样不太方便且容易出错的，更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有的与打包相关的信息放在里面。</p>
<p>当前文件夹的根目录下新建一个名为<code>webpack.config.js</code>的文件，我们在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。</p>
<pre><code class="language-js">const path = require('path');
const webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');
module.exports = {
    entry: {
       //入口
    },
    output: {
       //输出
    },
    module: {
        rules: [
            //打包规则
        ]
    },
    devtool: 'cheap-module-source-map',  //生成Source Maps（使调试更容易）
    //使用webpack-dev-server
    devServer: {
       //本地调试
    },
    plugins: [
    	//插件
  	]
};
</code></pre>
<h2 id="externals">externals</h2>
<p>如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者<code>window/global</code>全局等方式进行使用，那就可以通过配置<code>externals</code>。</p>
<p>例如<code>externals</code>引入jquery后，那么不管在代码中使用</p>
<pre><code class="language-js">import $ from 'jquery'
</code></pre>
<p>还是</p>
<pre><code class="language-js">var $ = require('jquery');
</code></pre>
<p>这些代码都能在浏览器中很好的执行。</p>
<p><code>externals</code> 支持以下模块上下文(module context)</p>
<ul>
<li><code>global</code> - 外部 library 能够作为全局变量使用。用户可以通过在 script 标签中引入来实现。这是 <code>externals</code> 的默认设置。</li>
<li><code>commonjs</code> - 用户(consumer)应用程序可能使用 CommonJS 模块系统，因此外部 library 应该使用 <code>CommonJS</code> 模块系统，并且应该是一个 CommonJS 模块。</li>
<li><code>commonjs2</code> - 类似上面几行，但导出的是 <code>module.exports.default</code>。</li>
<li><code>amd</code> - 类似上面几行，但使用 AMD 模块系统。</li>
</ul>
<p>如果你的代码想运行在Node环境中，那么你需要在external中添加前缀<code>commonjs2</code>或者<code>commonjs</code></p>
<pre><code class="language-js">externals:{
  react:'commonjs2 react',
  jquery:'commonjs2 jquery'
}
</code></pre>
<p>如果需要requirejs等符合AMD规范的环境中加载，那就要添加amd</p>
<pre><code class="language-js">externals:{
  react:'amd React',
  jquery:'amd jQuery'
}
</code></pre>
<p>如果要在浏览器中运行，那么不用添加什么前缀，默认设置就是global。</p>
<pre><code class="language-js">externals:{
  react:'React',
  jquery:'jQuery'
}
</code></pre>
<p>也可以这样</p>
<pre><code class="language-js">externals:[&quot;React&quot;,&quot;jQuery&quot;]
</code></pre>
<h2 id="生成source-maps">生成source maps</h2>
<p>通过简单的配置，webpack就可以在打包时为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。</p>
<pre><code class="language-js"> devtool: 'cheap-module-source-map',  //生成Source Maps（使调试更容易）
</code></pre>
<p>在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下：</p>
<table>
<thead>
<tr>
<th>devtool选项</th>
<th>配置结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>source-map</td>
<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>
</tr>
<tr>
<td>cheap-module-eval-source-map</td>
<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>
</tr>
</tbody>
</table>
<h2 id="构建本地服务器">构建本地服务器</h2>
<p>Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖</p>
<pre><code class="language-sh">npm install --save-dev webpack-dev-server
</code></pre>
<p>以下是它的一些配置选项：</p>
<ul>
<li><code>contentBase</code>	默认<code>webpack-dev-serve</code>r会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public&quot;目录）</li>
<li><code>port</code>	设置默认监听端口，如果省略，默认为”8080“</li>
<li><code>inline</code>	设置为true，当源文件改变时会自动刷新页面</li>
<li><code>historyApiFallback</code>	在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</li>
</ul>
<p>然后在<code>webpack.config.js</code>中进行配置：</p>
<pre><code class="language-js"> devServer: {
    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录
    historyApiFallback: true,//不跳转
    inline: true//实时刷新
  } 
</code></pre>
<p>在终端使用下面的命令即可启用</p>
<pre><code class="language-sh">webpack-dev-server --open
</code></pre>
<h2 id="loaders使用">Loaders使用</h2>
<ul>
<li>
<h4 id="babel使用">Babel使用</h4>
</li>
</ul>
<pre><code class="language-sh">npm install --save-dev babel-core babel-loader babel-preset-env
</code></pre>
<p>在<code>webpack.config.js</code>中加入</p>
<pre><code class="language-js">{
    test: /(\.jsx|\.js)$/,
    use: {
           loader: &quot;babel-loader&quot;
         },
    exclude: /node_modules/
    }
</code></pre>
<p>在项目根目录新建一个<code>.babelrc</code>文件</p>
<pre><code class="language-js">{
  &quot;presets&quot;: [ &quot;env&quot; ]
}
</code></pre>
<ul>
<li>
<h4 id="css处理">Css处理</h4>
</li>
</ul>
<p>webpack提供两个工具处理样式表，<code>css-loader</code> 和 <code>style-loader</code>，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,<code>style-loader</code>将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中</p>
<pre><code class="language-sh">//安装
npm install --save-dev style-loader css-loader
</code></pre>
<pre><code class="language-sh">{
     test: /\.css$/,
     use: [{
              loader: &quot;style-loader&quot;
            }, {
              loader: &quot;css-loader&quot;
            }
           ]
}
</code></pre>
<ul>
<li>
<h4 id="css-module">Css module</h4>
</li>
</ul>
<p>官方文档<a href="https://github.com/css-modules/css-modules" rel="nofollow" target="_blank">https://github.com/css-modules/css-modules</a><br>
被称为CSS modules的技术意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。</p>
<pre><code class="language-js">{
    test: /\.css$/,
    use: [
          {
            loader: &quot;style-loader&quot;
           }, {
            loader: &quot;css-loader&quot;,
            options: {
                modules: true, // 指定启用css modules
                localIdentName: '[name]__[local]--[hash:base64:5]' // 指定css的类名格式
                   }
           }
      ]
}
</code></pre>
<ul>
<li>
<h4 id="css预处理器">Css预处理器</h4>
</li>
</ul>
<p>以下是常用的CSS 处理loaders:<br>
- Less Loader<br>
- Sass Loader<br>
- Stylus Loader<br>
不过其实也存在一个CSS的处理平台-PostCSS，它可以帮助你的CSS实现更多的功能，官方文档<a href="https://github.com/postcss/postcss" target="" rel="nofollow">https://github.com/postcss/postcss</a></p>
<pre><code class="language-js">{
    test: /\.less$/,
    use: [{
           loader: &quot;style-loader&quot;
         }, {
           loader: &quot;css-loader&quot;,
           options: {
                modules: true
                  }
          }, {
            loader: &quot;less-loader&quot;
        }]
}
</code></pre>
<ul>
<li>
<h4 id="静态资源处理">静态资源处理</h4>
</li>
</ul>
<p>对于静态资源文件可以使用 <code>file-loader</code> 和 <code>url-loader</code>，前者试用于任何文件格式，后者专注于图片格式，并且对于小图片可以生成base64格式</p>
<pre><code class="language-js">{
    test: /\.(woff|woff2|ttf|eot|svg)(\?v=[0-9]\.[0-9]\.[0-9])?$/,
    use:[&quot;file-loader&quot;]
},
{
    test: /\.(png|jpg|gif)$/,
    use: [{
          loader: 'url-loader',
          options: {
              limit: 8192
           }
      }]
}
</code></pre>
<ul>
<li>
<h4 id="html-loader">html-loader</h4>
</li>
</ul>
<p>html-loader 将解析 URL,并请求图片和你所期望的一切资源</p>
<pre><code class="language-js"> {
    test: /\.html$/,
    use: {
       loader: 'html-loader',
       options: {
            attrs: ['img:src','img:data-src']
       }
     }
}
</code></pre>
<h2 id="插件使用">插件使用</h2>
<ul>
<li>
<h4 id="htmlwebpackplugin"><code>HtmlWebpackPlugin</code></h4>
</li>
</ul>
<p>这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）</p>
<pre><code class="language-sh">npm install --save-dev html-webpack-plugin
</code></pre>
<pre><code class="language-js">new HtmlWebpackPlugin({
  title: 'test',
  inject: 'head',
  favicon: '',
  minify: { //压缩HTML文件  
        removeComments: true, //移除HTML中的注释
        collapseWhitespace: true //删除空白符与换行符
  },
  hash: true,    //为静态资源生成hash值
  filename: 'index1.html',
  chunks: ['bundle1'] ,  //需要引入的chunk，不配置就会引入所有页面的资源
  template: __dirname + &quot;/app/html/index1.html&quot;//new 一个这个插件的实例，并传入相关的参数
})
</code></pre>
<ul>
<li>
<h4 id="hot-module-replacement"><code>Hot Module Replacement</code></h4>
</li>
</ul>
<p><code>Hot Module Replacement</code>（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。</p>
<pre><code>在webpack中实现HMR也很简单，只需要做两项配置
- 在webpack配置文件中添加HMR插件；
- 在Webpack Dev Server中添加“hot”参数；
</code></pre>
<p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。</p>
<pre><code>整理下我们的思路，具体实现方法如下
- Babel和webpack是独立的工具
- 二者可以一起工作
- 二者都可以通过插件拓展功能
- HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；
- Babel有一个叫做`react-transform-hrm`的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作；
</code></pre>
<p>还是继续上例来实际看看如何配置</p>
<pre><code class="language-js">const webpack = require('webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件
    output: {
        path: __dirname + &quot;/build&quot;,
        filename: &quot;bundle.js&quot;
    },
    devtool: 'eval-source-map',
    devServer: {
        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录
        historyApiFallback: true,//不跳转
        inline: true,
        hot: true
    },
    module: {
        rules: [
            {
                test: /(\.jsx|\.js)$/,
                use: {
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/
            },
            {
                test: /\.css$/,
                use: [
                    {
                        loader: &quot;style-loader&quot;
                    }, {
                        loader: &quot;css-loader&quot;,
                        options: {
                            modules: true
                        }
                    }, {
                        loader: &quot;postcss-loader&quot;
                    }
                ]
            }
        ]
    },
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),
        new HtmlWebpackPlugin({
            template: __dirname + &quot;/app/index.tmpl.html&quot;//new 一个这个插件的实例，并传入相关的参数
        }),
        new webpack.HotModuleReplacementPlugin()//热加载插件
    ],
};
</code></pre>
<p>安装<code>react-transform-hmr</code></p>
<pre><code class="language-sh">npm install --save-dev babel-plugin-react-transform react-transform-hmr
</code></pre>
<p>配置Babel</p>
<pre><code class="language-js">// .babelrc
{
  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;],
  &quot;env&quot;: {
    &quot;development&quot;: {
    &quot;plugins&quot;: [[&quot;react-transform&quot;, {
       &quot;transforms&quot;: [{
         &quot;transform&quot;: &quot;react-transform-hmr&quot;,
         
         &quot;imports&quot;: [&quot;react&quot;],
         
         &quot;locals&quot;: [&quot;module&quot;]
       }]
     }]]
    }
  }
}
</code></pre>
<p>现在当你使用React时，可以热加载模块了,每次保存就能在浏览器上看到更新内容。</p>
<ul>
<li>
<h4 id="extracttextplugin"><code>ExtractTextPlugin</code></h4>
</li>
</ul>
<p><code>ExtractTextPlugin</code>可以分离CSS和JS文件</p>
<pre><code class="language-js">const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
                 fallback: &quot;style-loader&quot;,
                 use: [{
                         loader: 'css-loader',
                         options:{
                              minimize: true //css压缩
                         }
                       },
                         &quot;less-loader&quot;
                   ]
        })
      }
    ]
  },
  plugins: [
    new ExtractTextPlugin(&quot;styles.css&quot;),
  ]
}
</code></pre>
<ul>
<li>
<h4 id="uglifyjsplugin"><code>UglifyJsPlugin</code></h4>
</li>
</ul>
<p>用来压缩JS代码</p>
<pre><code class="language-js">const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
module.exports = {
  plugins: [
    new UglifyJsPlugin()
  ]
}
</code></pre>
<ul>
<li>
<h4 id="clean-webpack-plugin"><code>clean-webpack-plugin</code></h4>
</li>
</ul>
<p>在再次build之前清除打包目录</p>
<pre><code class="language-js">const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);
plugins: [
    new CleanWebpackPlugin('build/*.*', {
      root: __dirname,
      verbose: true,
      dry: false
  })
]
</code></pre>
<ul>
<li>
<h4 id="commonschunkplugin"><code>CommonsChunkPlugin</code></h4>
</li>
</ul>
<p><code>CommonsChunkPlugin</code> 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件</p>
<pre><code class="language-js">new webpack.optimize.CommonsChunkPlugin({
  name: &quot;commons&quot;,
  // ( 公共chunk(commnons chunk) 的名称)
  filename: &quot;commons.js&quot;,
  // ( 公共chunk 的文件名)
  // minChunks: 3,
  // (模块必须被3个 入口chunk 共享)
  // chunks: [&quot;pageA&quot;, &quot;pageB&quot;],
  // (只使用这些 入口chunk)
})
</code></pre>
<p>可以查看这篇文章，写的很详细<a href="https://segmentfault.com/a/1190000006808865" target="_blank" rel="nofollow">webpack CommonsChunkPlugin详细教程</a></p>
<h2 id="发布">发布</h2>
<p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。</p>
<p>对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个<code>webpack.production.config.js</code>的文件，在里面加上基本的配置,它和原始的<code>webpack.config.j</code>s很像，不同的地方有：</p>
<ul>
<li>将 <code>devtool</code>设置为 'null'，这能大大压缩我们的打包代码</li>
<li><code>DefinePlugin</code>：定义环境变量</li>
<li><code>webpack.LoaderOptionsPlugin</code>：去除调试代码，压缩代码</li>
<li>去掉热加载功能</li>
<li><code>webpack.optimize.UglifyJsPlugin</code>：针对JS的混淆配置</li>
<li><code>CopyWebpackPlugin</code>：复制手动引入的资源文件到指定目录</li>
<li>去掉本地服务器功能</li>
<li>修改<code>publicPath</code>静态资源路径</li>
</ul>
<h2 id="注意点">注意点</h2>
<ul>
<li>
<h4 id="loader与plugin区别">Loader与plugin区别</h4>
<ul>
<li>loader 用于加载某些资源文件。 因为webpack 本身只能打包<code>commonjs</code>规范的js文件，对于<br>
其他资源例如 css，图片，或者其他的语法集，比如 jsx， coffee，是没有办法加载的。 这就<br>
需要对应的loader将资源转化，加载进来。从字面意思也能看出，loader是用于加载的，它作用<br>
于一个个文件上。</li>
<li>plugin 用于扩展webpack的功能。它直接作用于 webpack，扩展了它的功能。当然loader也<br>
时变相的扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域。而plugin的<br>
功能更加的丰富，而不仅局限于资源的加载。</li>
</ul>
</li>
<li>
<h4 id="publicpath"><code>publicPath</code></h4>
</li>
</ul>
<p>指定资源文件引用的目录，只会改变页面上资源的引用，不会改变资源打包后的位置</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="nofollow">阮一峰的webpack实例</a></li>
<li><a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="nofollow">入门Webpack，看这篇就够了</a></li>
<li><a href="http://www.css88.com/doc/webpack/plugins/commons-chunk-plugin/" target="_blank" rel="nofollow">Webpack 3 中文文档</a></li>
<li><a href="https://github.com/css-modules/css-modules" rel="nofollow" target="_blank">CSS Module</a></li>
<li><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="nofollow">Webpack中文文档概念</a></li>
<li><a href="https://doc.webpack-china.org/configuration/" target="_blank" rel="nofollow">Webpack中文文档配置</a></li>
<li><a href="https://doc.webpack-china.org/api/" target="_blank" rel="nofollow">Webpack中文文档API</a></li>
<li><a href="https://doc.webpack-china.org/guides/" target="_blank" rel="nofollow">Webpack中文文档指南</a></li>
<li><a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="nofollow">Webpack中文文档Loaders列表与使用方法</a></li>
<li><a href="https://doc.webpack-china.org/plugins/" target="_blank" rel="nofollow">Webpack中文文档插件列表与使用方法</a></li>
<li><a href="https://www.npmjs.com/package/extract-text-webpack-plugin" target="_blank" rel="nofollow">extract-text-webpack-plugin</a></li>
<li><a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="nofollow">html-webpack-plugin</a></li>
<li><a href="https://www.npmjs.com/package/file-loader" target="_blank" rel="nofollow">file-loader</a></li>
<li><a href="https://www.npmjs.com/package/url-loader" target="_blank" rel="nofollow">url-loader</a></li>
<li><a href="https://www.npmjs.com/package/html-loader" target="_blank" rel="nofollow">html-loader</a></li>
<li><a href="http://www.css88.com/doc/webpack/plugins/commons-chunk-plugin/" target="_blank" rel="nofollow">CommonChunkPlugin</a></li>
</ul>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://huxinmin.github.io/post/js-yuan-xing-yi-ji-yuan-xing-lian-ji-cheng-xiang-jie/">
                                    <h3 class="post-title">
                                        Js原型以及原型链继承详解
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
        <a href="#!" id="tool-toc" class="hidden-xs hidden-sm">
            <i class="fa fa-map"></i>
        </a>
        <br>
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#webpack%E7%AE%80%E4%BB%8B">Webpack简介</a></li>
<li><a href="#why-webpack">Why Webpack?</a></li>
<li><a href="#webpack%E4%B8%8Egulp%E4%BB%A5%E5%8F%8Agrunt%E7%9A%84%E5%AF%B9%E6%AF%94%E5%8C%BA%E5%88%AB">Webpack与gulp以及grunt的对比区别</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a><br>
*
<ul>
<li><a href="#%E5%85%A5%E5%8F%A3">入口</a></li>
<li><a href="#%E5%87%BA%E5%8F%A3">出口</a></li>
<li><a href="#loader">Loader</a></li>
<li><a href="#%E6%8F%92%E4%BB%B6">插件</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">开始使用</a><br>
*
<ul>
<li><a href="#%E5%88%9B%E5%BB%BApackagejson">创建<code>package.json</code></a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AEnpm-script">设置<code>npm script</code></a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#externals">externals</a></li>
<li><a href="#%E7%94%9F%E6%88%90source-maps">生成source maps</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">构建本地服务器</a></li>
<li><a href="#loaders%E4%BD%BF%E7%94%A8">Loaders使用</a><br>
*
<ul>
<li><a href="#babel%E4%BD%BF%E7%94%A8">Babel使用</a></li>
<li><a href="#css%E5%A4%84%E7%90%86">Css处理</a></li>
<li><a href="#css-module">Css module</a></li>
<li><a href="#css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">Css预处理器</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86">静态资源处理</a></li>
<li><a href="#html-loader">html-loader</a></li>
</ul>
</li>
<li><a href="#%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8">插件使用</a><br>
*
<ul>
<li><a href="#htmlwebpackplugin"><code>HtmlWebpackPlugin</code></a></li>
<li><a href="#hot-module-replacement"><code>Hot Module Replacement</code></a></li>
<li><a href="#extracttextplugin"><code>ExtractTextPlugin</code></a></li>
<li><a href="#uglifyjsplugin"><code>UglifyJsPlugin</code></a></li>
<li><a href="#clean-webpack-plugin"><code>clean-webpack-plugin</code></a></li>
<li><a href="#commonschunkplugin"><code>CommonsChunkPlugin</code></a></li>
</ul>
</li>
<li><a href="#%E5%8F%91%E5%B8%83">发布</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</a><br>
*
<ul>
<li><a href="#loader%E4%B8%8Eplugin%E5%8C%BA%E5%88%AB">Loader与plugin区别</a></li>
<li><a href="#publicpath"><code>publicPath</code></a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>

</div>


    
<footer id="fh5co-footer">
  <p>Powered by <a href="https://huxinmin.github.io" target="_blank">胡新敏的个人博客</a></p>
</footer>


    <!-- jQuery -->
<script src="https://huxinmin.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://huxinmin.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://huxinmin.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://huxinmin.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://huxinmin.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://huxinmin.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://huxinmin.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
        var allImg = $("img");
        allImg.on("contextmenu", function () {
            return false;
        });
        allImg.on("dragstart", function () {
            return false;
        });
    
</script>




</body>
</html>
