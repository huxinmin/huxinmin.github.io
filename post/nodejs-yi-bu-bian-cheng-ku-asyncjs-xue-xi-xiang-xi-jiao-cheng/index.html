<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>胡新敏的个人博客</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="胡新敏的个人博客"/>
<meta name="keywords" content="胡新敏的个人博客"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://huxinmin.github.io/favicon.ico">

<link rel="stylesheet" href="https://huxinmin.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://huxinmin.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://huxinmin.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://huxinmin.github.io/images/avatar.png" alt="胡新敏的个人博客"
                 class="img-responsive">
        </figure>
        <a href="https://huxinmin.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>胡新敏的个人博客</h2>
        <p>胡新敏的个人博客</p>
        <ul class="fh5co-social">
            
                <li>
                    
                        <a href="https://github.com/huxinmin" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                        <a href="https://www.zhihu.com/people/hu-xin-min-99" target="_blank">
                            <i class="fab fa-zhihu"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://huxinmin.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://huxinmin.github.io/tag/mSeB0wbbH/">linux</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/0CEgc5Nuc/">react</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/7tyyR9fOk/">ja</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/AzH6zVqFK/">js</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/UJq-iLfq6/">restful</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/r0zynGCMV/">http</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/GNbObqsVG/">json</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/dZU9srOJ4/">moment.js</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/wsD4ABEPz/">数据库</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/tq8jF2xcA/">mongoose</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/VL5yScL71/">mongodb</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/XRK7arMJO/">nodejs</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/DJMLUSVfi/">html5</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/oHlYLx_Tl/">websocket</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/8-tAS0eFO/">nginx</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/X3jlBk5nJ/">css</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/H8XsrzQ7e/">css3</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/J27JVlP2F/">文件上传</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/X3Z7s8kF_/">jquery</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/CrwH886ky/">ajax</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/s0bxFP3uF/">express</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/ZSDYSDwY2/">其他</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/4OX23_HC0/">jest</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/JavlGTiRY/">editorconfig</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/pTofQIx8N/">待办事宜</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/8u7cjaUBn/">随笔</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/knySerdH-/">git</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/NSyjPJZkv/">aws</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/pU8c2aJR5/">webassembly</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/UsaB01y9b/">sublime</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/oVWhBDgSF/">centos</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/JqHVZntTk/">putty</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/HOjS4qCUx/">npm</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            标签
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            关于
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://huxinmin.github.io">胡新敏的个人博客 </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
            </span>
            <h2 class="fh5co-article-title animate-box">Nodejs异步编程库Async.js学习详细教程</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2020-04-20</li>
                <li>5029字</li>
                <li>26 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <h2 id="前言">前言</h2>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。nodejs是基于异步的写法，有时一个函数需要上一个函数的返回值做参数，对于一些复杂的异步流程操作，就会使得代码变得支离破碎，难以看懂或维护。</p>
<p>怎样才能写出优雅的异步流程代码呢，市面上已经有很多的解决方案，例如Promise以及co等，今天我们一起来学习一下<code>async.js</code>这款框架。</p>
<h2 id="asyncjs介绍"><code>Async.js</code>介绍</h2>
<p>Async是一个提供了直接高效操作异步Js的工具模块，可以同时运行在Nodejs和浏览器端，它提供了将近70多个函数，包括常见的<code>map</code>，<code>reduce</code>，<code>filter</code>，<code>each</code>等。所有的函数都需要你遵守Nodejs的约定也就是异步方法的最后一个参数返回一个函数，函数的第一个参数是Error，并且只执行一次。</p>
<h2 id="asyncjs安装"><code>Async.js</code>安装</h2>
<p>使用NPM进行安装：</p>
<pre><code class="language-sh">$ npm install --save async
</code></pre>
<p>使用bower进行安装：</p>
<pre><code class="language-sh">$ bower install async
</code></pre>
<p>然后就能使用了：</p>
<pre><code class="language-js">var async = require(&quot;async&quot;);
</code></pre>
<p>或者使用其中的一个独立模块：</p>
<pre><code class="language-js">var waterfall = require(&quot;async/waterfall&quot;);
var map = require(&quot;async/map&quot;);
</code></pre>
<p>在浏览器中，引入即可：</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot; src=&quot;async.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>如果想要安装ES2015版本的话：</p>
<pre><code class="language-sh">$ npm install --save async-es
</code></pre>
<p>使用：</p>
<pre><code class="language-js">import waterfall from 'async-es/waterfall';
import async from 'async-es';
</code></pre>
<h2 id="asyncjs集合类操作方法"><code>Async.js</code>集合类操作方法</h2>
<h4 id="concatcoll-iteratee-callbackerropt"><code>concat(coll, iteratee, callback(err)opt)</code></h4>
<p>并行执行迭代器，返回处理结果的合并后的集合，但是不能保证集合顺序。</p>
<pre><code class="language-js">async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
    // files为数组，数组中元素为三个文件夹下面的所有文件名集合
});
</code></pre>
<p>实例：</p>
<pre><code class="language-js">async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
    // 返回一个数组，该数组的元素为文件夹中所有的文件名的集合
});
</code></pre>
<h4 id="concatlimitcoll-limit-iteratee-callbackopt"><code>concatLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p>同concat，只是限制了并行运行的数量</p>
<h4 id="concatseriescoll-iteratee-callbackerropt"><code>concatSeries(coll, iteratee, callback(err)opt)</code></h4>
<p>concat的串行版本</p>
<h4 id="detectcoll-iteratee-callbackopt"><code>detect(coll, iteratee, callbackopt)</code></h4>
<p>并行执行迭代器，返回第一个（不能保证顺序）执行为真的值。</p>
<p>实例：</p>
<pre><code class="language-js">async.detect(['file1','file2','file3'], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, result) {
    // result等于第一个存在着的文件的文件名
});
</code></pre>
<h4 id="detectlimitcoll-limit-iteratee-callbackopt"><code>detectLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p>同<code>detect</code>，限制了并行运行的数量</p>
<h4 id="detectseriescoll-iteratee-callbackopt"><code>detectSeries(coll, iteratee, callbackopt)</code></h4>
<p><code>detect</code>串行版本</p>
<h4 id="eachcoll-iteratee-callbackopt"><code>each(coll, iteratee, callbackopt)</code></h4>
<p>并行地给每个元素执行回调函数</p>
<p>实例：</p>
<pre><code class="language-js">async.each(openFiles, saveFile, function(err){
  // 如果其中一个运行出错，err会等于那个错误
});
</code></pre>
<h4 id="eachlimitcoll-limit-iteratee-callbackopt"><code>eachLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p>同<code>each</code>但是限制了并行运行的数量</p>
<h4 id="eachseriescoll-iteratee-callbackopt"><code>eachSeries(coll, iteratee, callbackopt)</code></h4>
<p><code>each</code>的串行版本</p>
<h4 id="eachofcoll-iteratee-callbackopt"><code>eachOf(coll, iteratee, callbackopt)</code></h4>
<p>同<code>each</code>，但是比之多了一个序列</p>
<p>实例：</p>
<pre><code class="language-js">var obj = {dev: &quot;/dev.json&quot;, test: &quot;/test.json&quot;, prod: &quot;/prod.json&quot;};
var configs = {};
async.forEachOf(obj, function (value, key, callback) {
    fs.readFile(__dirname + value, &quot;utf8&quot;, function (err, data) {
        if (err) return callback(err);
        try {
            configs[key] = JSON.parse(data);
        } catch (e) {
            return callback(e);
        }
        callback();
    });
}, function (err) {
    if (err) console.error(err.message);
    // configs is now a map of JSON data
    doSomethingWith(configs);
});
</code></pre>
<h4 id="eachoflimitcoll-limit-iteratee-callbackopt"><code>eachOfLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p>同<code>eachof</code>但是限制了并发数</p>
<h4 id="eachofseriescoll-iteratee-callbackopt"><code>eachOfSeries(coll, iteratee, callbackopt)</code></h4>
<p><code>eachof</code>的串行版本</p>
<h4 id="everycoll-iteratee-callbackopt"><code>every(coll, iteratee, callbackopt)</code></h4>
<p>所有的测试都满足才返回<code>true</code>，只要一个不满足就返回<code>false</code></p>
<p>实例：</p>
<pre><code class="language-js">async.every(['file1','file2','file3'], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, result) {
    // if result is true then every file exists
});
</code></pre>
<h4 id="everylimitcoll-limit-iteratee-callbackopt"><code>everyLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p><code>every</code>的限制并发数版</p>
<h4 id="everyseriescoll-iteratee-callbackopt"><code>everySeries(coll, iteratee, callbackopt)</code></h4>
<p><code>every</code>的串行版</p>
<h4 id="filtercoll-iteratee-callbackopt"><code>filter(coll, iteratee, callbackopt)</code></h4>
<p>并行地选出符合条件的新数组，顺序不变。</p>
<p>实例：</p>
<pre><code class="language-js">async.filter(['file1','file2','file3'], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, results) {
    // results now equals an array of the existing files
});
</code></pre>
<h4 id="filterlimitcoll-limit-iteratee-callbackopt"><code>filterLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p><code>filter</code>限制并行数版</p>
<h4 id="filterseriescoll-iteratee-callbackopt"><code>filterSeries(coll, iteratee, callbackopt)</code></h4>
<p><code>filter</code>串行版</p>
<h4 id="groupbycoll-iteratee-callbackopt"><code>groupBy(coll, iteratee, callbackopt)</code></h4>
<p>使用coll中某一个key进行分组，返回一个新的对象，key是用来分组的对应的值，value是一个数组，是刚才coll中符合要求的值集合，并行执行，不能保证顺序</p>
<p>实例：</p>
<pre><code class="language-js">async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
    db.findById(userId, function(err, user) {
        if (err) return callback(err);
        return callback(null, user.age);
    });
}, function(err, result) {
    // result is object containing the userIds grouped by age
    // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
});
</code></pre>
<h4 id="groupbylimitcoll-limit-iteratee-callbackopt"><code>groupByLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p><code>group</code>限制并发数版</p>
<h4 id="groupbyseriescoll-limit-iteratee-callbackopt"><code>groupBySeries(coll, limit, iteratee, callbackopt)</code></h4>
<p><code>group</code>串行版</p>
<h4 id="mapcoll-iteratee-callbackopt"><code>map(coll, iteratee, callbackopt)</code></h4>
<p>并行地进行映射成新的集合，虽然不能保证完成的顺序，但是能保证结果的顺序不变</p>
<p>实例：</p>
<pre><code class="language-js">async.map(['file1','file2','file3'], fs.stat, function(err, results) {
    // results is now an array of stats for each file
});
</code></pre>
<h4 id="maplimitcoll-limit-iteratee-callbackopt"><code>mapLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p><code>map</code>限制并发数版</p>
<h4 id="mapseriescoll-iteratee-callbackopt"><code>mapSeries(coll, iteratee, callbackopt)</code></h4>
<p><code>map</code>串行版</p>
<h4 id="mapvaluesobj-iteratee-callbackopt"><code>mapValues(obj, iteratee, callbackopt)</code></h4>
<p>为对象设计的<code>map</code></p>
<p>实例：</p>
<pre><code class="language-js">async.mapValues({
    f1: 'file1',
    f2: 'file2',
    f3: 'file3'
}, function (file, key, callback) {
  fs.stat(file, callback);
}, function(err, result) {
    // result is now a map of stats for each file, e.g.
    // {
    //     f1: [stats for file1],
    //     f2: [stats for file2],
    //     f3: [stats for file3]
    // }
});
</code></pre>
<h4 id="mapvalueslimitobj-limit-iteratee-callbackopt"><code>mapValuesLimit(obj, limit, iteratee, callbackopt)</code></h4>
<p><code>map</code>限制并发数版</p>
<h4 id="mapvaluesseriesobj-iteratee-callbackopt"><code>mapValuesSeries(obj, iteratee, callbackopt)</code></h4>
<p><code>map</code>串行版</p>
<h4 id="reducecoll-memo-iteratee-callbackopt"><code>reduce(coll, memo, iteratee, callbackopt)</code></h4>
<p>串行递归计算出值</p>
<p>实例：</p>
<pre><code class="language-js">async.reduce([1,2,3], 0, function(memo, item, callback) {
    // 无意义地异步
    process.nextTick(function() {
        callback(null, memo + item)
    });
}, function(err, result) {
    // result is now equal to the last value of memo, which is 6
});
</code></pre>
<h4 id="reducerightarray-memo-iteratee-callbackopt"><code>reduceRight(array, memo, iteratee, callbackopt)</code></h4>
<p>从右边开始进行递归</p>
<h4 id="rejectcoll-iteratee-callbackopt"><code>reject(coll, iteratee, callbackopt)</code></h4>
<p>与<code>filter</code>相反，移除符合条件的值</p>
<p>实例：</p>
<pre><code class="language-js">async.reject(['file1','file2','file3'], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, results) {
    // results now equals an array of missing files
    createFiles(results);
});
</code></pre>
<h4 id="rejectlimitcoll-limit-iteratee-callbackopt"><code>rejectLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p><code>reject</code>限制并发数版</p>
<h4 id="rejectseriescoll-iteratee-callbackopt"><code>rejectSeries(coll, iteratee, callbackopt)</code></h4>
<p><code>reject</code>串行版</p>
<h4 id="somecoll-iteratee-callbackopt"><code>some(coll, iteratee, callbackopt)</code></h4>
<p>只要有一个符合条件就返回<code>true</code></p>
<p>实例：</p>
<pre><code class="language-js">async.some(['file1','file2','file3'], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, result) {
    // if result is true then at least one of the files exists
});
</code></pre>
<h4 id="somelimitcoll-limit-iteratee-callbackopt"><code>someLimit(coll, limit, iteratee, callbackopt)</code></h4>
<p><code>some</code>的限制并发数版</p>
<h4 id="someseriescoll-iteratee-callbackopt"><code>someSeries(coll, iteratee, callbackopt)</code></h4>
<p><code>some</code>的串行版</p>
<h4 id="sortbycoll-iteratee-callback"><code>sortBy(coll, iteratee, callback)</code></h4>
<p>对集合进行排序</p>
<p>实例：</p>
<pre><code class="language-js">//升序
async.sortBy([1,9,3,5], function(x, callback) {
    callback(null, x);
}, function(err,result) {
    // result callback
});
// 降序
async.sortBy([1,9,3,5], function(x, callback) {
    callback(null, x*-1);    //&lt;- x*-1 instead of x, turns the order around
}, function(err,result) {
    // result callback
});
</code></pre>
<h4 id="transformcoll-accumulatoropt-iteratee-callbackopt"><code>transform(coll, accumulatoropt, iteratee, callbackopt)</code></h4>
<p>不断改变叠加器，最后输出</p>
<p>实例：</p>
<pre><code class="language-js">async.transform([1,2,3], function(acc, item, index, callback) {
    // pointless async:
    process.nextTick(function() {
        acc.push(item * 2)
        callback(null)
    });
}, function(err, result) {
    // result is now equal to [2, 4, 6]
});
</code></pre>
<h2 id="asyncjs流程控制方法"><code>Async.js</code>流程控制方法</h2>
<h4 id="applyeachfns-argsopt-callbackopt"><code>applyEach(fns, …argsopt, callbackopt)</code></h4>
<p>为数组中的每个函数应用提供的参数，如果只提供了函数数组，将会返回一个函数允许你继续传入参数。</p>
<p>实例：</p>
<pre><code class="language-js">async.applyEach([enableSearch, updateSchema], 'bucket', callback);
</code></pre>
<h4 id="applyeachseriesfns-argsopt-callbackopt"><code>applyEachSeries(fns, …argsopt, callbackopt)</code></h4>
<p><code>applyEach</code>串行版本</p>
<h4 id="autotasks-concurrencyopt-callbackopt"><code>auto(tasks, concurrencyopt, callbackopt)</code></h4>
<p>根据依赖，决定任务的执行先后顺序</p>
<p>实例：</p>
<pre><code class="language-js">async.auto({
    // this function will just be passed a callback
    readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
    showData: ['readData', function(results, cb) {
        // results.readData is the file's contents
        // ...
    }]
}, callback);
async.auto({
    get_data: function(callback) {
        console.log('in get_data');
        // async code to get some data
        callback(null, 'data', 'converted to array');
    },
    make_folder: function(callback) {
        console.log('in make_folder');
        // async code to create a directory to store a file in
        // this is run at the same time as getting the data
        callback(null, 'folder');
    },
    write_file: ['get_data', 'make_folder', function(results, callback) {
        console.log('in write_file', JSON.stringify(results));
        // once there is some data and the directory exists,
        // write the data to a file in the directory
        callback(null, 'filename');
    }],
    email_link: ['write_file', function(results, callback) {
        console.log('in email_link', JSON.stringify(results));
        // once the file is written let's email a link to it...
        // results.write_file contains the filename returned by write_file.
        callback(null, {'file':results.write_file, 'email':'user@example.com'});
    }]
}, function(err, results) {
    console.log('err = ', err);
    console.log('results = ', results);
});
</code></pre>
<h4 id="autoinjecttasks-callbackopt"><code>autoInject(tasks, callbackopt)</code></h4>
<p><code>auto</code>的依赖注入版本</p>
<p>实例：</p>
<pre><code class="language-js">//  The example from `auto` can be rewritten as follows:
async.autoInject({
    get_data: function(callback) {
        // async code to get some data
        callback(null, 'data', 'converted to array');
    },
    make_folder: function(callback) {
        // async code to create a directory to store a file in
        // this is run at the same time as getting the data
        callback(null, 'folder');
    },
    write_file: function(get_data, make_folder, callback) {
        // once there is some data and the directory exists,
        // write the data to a file in the directory
        callback(null, 'filename');
    },
    email_link: function(write_file, callback) {
        // once the file is written let's email a link to it...
        // write_file contains the filename returned by write_file.
        callback(null, {'file':write_file, 'email':'user@example.com'});
    }
}, function(err, results) {
    console.log('err = ', err);
    console.log('email_link = ', results.email_link);
});
// If you are using a JS minifier that mangles parameter names, `autoInject`
// will not work with plain functions, since the parameter names will be
// collapsed to a single letter identifier.  To work around this, you can
// explicitly specify the names of the parameters your task function needs
// in an array, similar to Angular.js dependency injection.
// This still has an advantage over plain `auto`, since the results a task
// depends on are still spread into arguments.
async.autoInject({
    //...
    write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
        callback(null, 'filename');
    }],
    email_link: ['write_file', function(write_file, callback) {
        callback(null, {'file':write_file, 'email':'user@example.com'});
    }]
    //...
}, function(err, results) {
    console.log('err = ', err);
    console.log('email_link = ', results.email_link);
});
</code></pre>
<h4 id="cargoworker-payloadopt"><code>cargo(worker, payloadopt)</code></h4>
<p>使用负载创建一个负载对象，添加到负载的任务会被同时执行</p>
<p>实例：</p>
<pre><code class="language-js">// create a cargo object with payload 2
var cargo = async.cargo(function(tasks, callback) {
    for (var i=0; i&lt;tasks.length; i++) {
        console.log('hello ' + tasks[i].name);
    }
    callback();
}, 2);
// add some items
cargo.push({name: 'foo'}, function(err) {
    console.log('finished processing foo');
});
cargo.push({name: 'bar'}, function(err) {
    console.log('finished processing bar');
});
cargo.push({name: 'baz'}, function(err) {
    console.log('finished processing baz');
});
</code></pre>
<h4 id="composefunctions"><code>compose(…functions)</code></h4>
<p>使用多个函数组成一个函数，每个函数会把下一个函数的返回值当做参数传入</p>
<p>实例：</p>
<pre><code class="language-js">function add1(n, callback) {
    setTimeout(function () {
        callback(null, n + 1);
    }, 10);
}
function mul3(n, callback) {
    setTimeout(function () {
        callback(null, n * 3);
    }, 10);
}
var add1mul3 = async.compose(mul3, add1);
add1mul3(4, function (err, result) {
    // result now equals 15
});
</code></pre>
<h4 id="doduringfn-test-callbackopt"><code>doDuring(fn, test, callbackopt)</code></h4>
<p>先执行再进行检查的<code>during</code>版本，调换了<code>fn</code>和<code>test</code>的顺序</p>
<h4 id="dountiliteratee-test-callbackopt"><code>doUntil(iteratee, test, callbackopt)</code></h4>
<p><code>until</code>的先执行在检查版本，调换了<code>fn</code>和<code>test</code>的顺序</p>
<h4 id="dowhilstiteratee-test-callbackopt"><code>doWhilst(iteratee, test, callbackopt)</code></h4>
<p><code>whilst</code>的先执行后检查版本，，调换了<code>fn</code>和<code>test</code>的顺序</p>
<h4 id="duringtest-fn-callbackopt"><code>during(test, fn, callbackopt)</code></h4>
<p>类似<code>whilst</code>，除了测试函数是一个异步函数通过<code>function (err, truth)</code>的形式</p>
<p>实例：</p>
<pre><code class="language-js">var count = 0;
async.during(
    function (callback) {
        return callback(null, count &lt; 5);
    },
    function (callback) {
        count++;
        setTimeout(callback, 1000);
    },
    function (err) {
        // 5秒后才执行
    }
);
</code></pre>
<h4 id="foreverfn-errbackopt"><code>forever(fn, errbackopt)</code></h4>
<p>无限执行</p>
<h4 id="paralleltasks-callbackopt"><code>parallel(tasks, callbackopt)</code></h4>
<p>并行执行</p>
<p>实例：</p>
<pre><code class="language-js">async.parallel([
    function(callback) {
        setTimeout(function() {
            callback(null, 'one');
        }, 200);
    },
    function(callback) {
        setTimeout(function() {
            callback(null, 'two');
        }, 100);
    }
],
// optional callback
function(err, results) {
    // the results array will equal ['one','two'] even though
    // the second function had a shorter timeout.
});
// an example using an object instead of an array
async.parallel({
    one: function(callback) {
        setTimeout(function() {
            callback(null, 1);
        }, 200);
    },
    two: function(callback) {
        setTimeout(function() {
            callback(null, 2);
        }, 100);
    }
}, function(err, results) {
    // results is now equals to: {one: 1, two: 2}
});
</code></pre>
<h4 id="parallellimittasks-limit-callbackopt"><code>parallelLimit(tasks, limit, callbackopt)</code></h4>
<p>限制并发数的<code>parallel</code>版本</p>
<h4 id="priorityqueueworker-concurrency"><code>priorityQueue(worker, concurrency)</code></h4>
<p>类似<code>queue</code>，不过会有一个权重机制，任务按照权重的升序顺序执行，与<code>queue</code>不同地方在于：<br>
<code>push(task, priority, [callback])</code>多了一个priority，并且没有<code>unshift</code>方法</p>
<h4 id="queueworker-concurrencyopt"><code>queue(worker, concurrencyopt)</code></h4>
<p>使用并发数创建一个队列对象，添加的任务会并行执行，只有上一个任务完成了才会执行下一个任务</p>
<p>实例：</p>
<pre><code class="language-js">// 创建并发数为2的队列
var q = async.queue(function(task, callback) {
    console.log('hello ' + task.name);
    callback();
}, 2);
// 创建完成回调
q.drain = function() {
    console.log('all items have been processed');
};
// 添加任务
q.push({name: 'foo'}, function(err) {
    console.log('finished processing foo');
});
q.push({name: 'bar'}, function (err) {
    console.log('finished processing bar');
});
// 添加多个任务
q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
    console.log('finished processing item');
});
// 在头部添加任务
q.unshift({name: 'bar'}, function (err) {
    console.log('finished processing bar');
});
</code></pre>
<h4 id="racetasks-callback"><code>race(tasks, callback)</code></h4>
<p>并行执行，只要有一个执行完成就算完成</p>
<p>实例：</p>
<pre><code class="language-js">async.race([
    function(callback) {
        setTimeout(function() {
            callback(null, 'one');
        }, 200);
    },
    function(callback) {
        setTimeout(function() {
            callback(null, 'two');
        }, 100);
    }
],
// main callback
function(err, result) {
    // the result will be equal to 'two' as it finishes earlier
});
</code></pre>
<h4 id="retryoptsopt-task-callbackopt"><code>retry(optsopt, task, callbackopt)</code></h4>
<p>尝试执行任务不超过规定次数</p>
<p>实例：</p>
<pre><code class="language-js">// The `retry` function can be used as a stand-alone control flow by passing
// a callback, as shown below:

// try calling apiMethod 3 times
async.retry(3, apiMethod, function(err, result) {
    // do something with the result
});

// try calling apiMethod 3 times, waiting 200 ms between each retry
async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
    // do something with the result
});

// try calling apiMethod 10 times with exponential backoff
// (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
async.retry({
  times: 10,
  interval: function(retryCount) {
    return 50 * Math.pow(2, retryCount);
  }
}, apiMethod, function(err, result) {
    // do something with the result
});

// try calling apiMethod the default 5 times no delay between each retry
async.retry(apiMethod, function(err, result) {
    // do something with the result
});

// try calling apiMethod only when error condition satisfies, all other
// errors will abort the retry control flow and return to final callback
async.retry({
  errorFilter: function(err) {
    return err.message === 'Temporary error'; // only retry on a specific error
  }
}, apiMethod, function(err, result) {
    // do something with the result
});

// to retry individual methods that are not as reliable within other
// control flow functions, use the `retryable` wrapper:
async.auto({
    users: api.getUsers.bind(api),
    payments: async.retryable(3, api.getPayments.bind(api))
}, function(err, results) {
    // do something with the results
});
</code></pre>
<h4 id="retryableoptsopt-task"><code>retryable(optsopt, task)</code></h4>
<p>使任务可被尝试多次执行的</p>
<p>实例：</p>
<pre><code class="language-js">async.auto({
    dep1: async.retryable(3, getFromFlakyService),
    process: [&quot;dep1&quot;, async.retryable(3, function (results, cb) {
        maybeProcessData(results.dep1, cb);
    })]
}, callback);
</code></pre>
<h4 id="seqfunctions"><code>seq(…functions)</code></h4>
<p><code>compose</code>的倒过来版，上一个函数的返回值是下一个函数的参数。</p>
<p>实例：</p>
<pre><code class="language-js">// Requires lodash (or underscore), express3 and dresende's orm2.
// Part of an app, that fetches cats of the logged user.
// This example uses `seq` function to avoid overnesting and error
// handling clutter.
app.get('/cats', function(request, response) {
    var User = request.models.User;
    async.seq(
        _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
        function(user, fn) {
            user.getCats(fn);      // 'getCats' has signature (callback(err, data))
        }
    )(req.session.user_id, function (err, cats) {
        if (err) {
            console.error(err);
            response.json({ status: 'error', message: err.message });
        } else {
            response.json({ status: 'ok', message: 'Cats found', data: cats });
        }
    });
});
</code></pre>
<h4 id="seriestasks-callbackopt"><code>series(tasks, callbackopt)</code></h4>
<p>串行执行函数</p>
<p>实例：</p>
<pre><code class="language-js">async.series([
    function(callback) {
        // do some stuff ...
        callback(null, 'one');
    },
    function(callback) {
        // do some more stuff ...
        callback(null, 'two');
    }
],
// optional callback
function(err, results) {
    // results is now equal to ['one', 'two']
});
async.series({
    one: function(callback) {
        setTimeout(function() {
            callback(null, 1);
        }, 200);
    },
    two: function(callback){
        setTimeout(function() {
            callback(null, 2);
        }, 100);
    }
}, function(err, results) {
    // results is now equal to: {one: 1, two: 2}
});
</code></pre>
<h4 id="timesn-iteratee-callback"><code>times(n, iteratee, callback)</code></h4>
<p>并行执行指定次数</p>
<p>实例：</p>
<pre><code class="language-js">// Pretend this is some complicated async factory
var createUser = function(id, callback) {
    callback(null, {
        id: 'user' + id
    });
};
// generate 5 users
async.times(5, function(n, next) {
    createUser(n, function(err, user) {
        next(err, user);
    });
}, function(err, users) {
    // we should now have 5 users
});
</code></pre>
<h4 id="timeslimitcount-limit-iteratee-callback"><code>timesLimit(count, limit, iteratee, callback)</code></h4>
<p><code>times</code>的限制并发数版</p>
<h4 id="timesseriesn-iteratee-callback"><code>timesSeries(n, iteratee, callback)</code></h4>
<p><code>times</code>的串行版</p>
<h4 id="tryeachtasks-callbackopt"><code>tryEach(tasks, callbackopt)</code></h4>
<p>串行执行，只要有一个成功则停止</p>
<p>实例：</p>
<pre><code class="language-js">async.tryEach([
    function getDataFromFirstWebsite(callback) {
        // Try getting the data from the first website
        callback(err, data);
    },
    function getDataFromSecondWebsite(callback) {
        // First website failed,
        // Try getting the data from the backup website
        callback(err, data);
    }
],
// optional callback
function(err, results) {
    Now do something with the data.
});
</code></pre>
<h4 id="untiltest-iteratee-callbackopt"><code>until(test, iteratee, callbackopt)</code></h4>
<p>直到检查函数返回为真才停止执行iteratee</p>
<h4 id="waterfalltasks-callbackopt"><code>waterfall(tasks, callbackopt)</code></h4>
<p>串行执行，将执行结果传递给接下来的函数</p>
<p>实例：</p>
<pre><code class="language-js">async.waterfall([
    function(callback) {
        callback(null, 'one', 'two');
    },
    function(arg1, arg2, callback) {
        // arg1 now equals 'one' and arg2 now equals 'two'
        callback(null, 'three');
    },
    function(arg1, callback) {
        // arg1 now equals 'three'
        callback(null, 'done');
    }
], function (err, result) {
    // result now equals 'done'
});
// Or, with named functions:
async.waterfall([
    myFirstFunction,
    mySecondFunction,
    myLastFunction,
], function (err, result) {
    // result now equals 'done'
});
function myFirstFunction(callback) {
    callback(null, 'one', 'two');
}
function mySecondFunction(arg1, arg2, callback) {
    // arg1 now equals 'one' and arg2 now equals 'two'
    callback(null, 'three');
}
function myLastFunction(arg1, callback) {
    // arg1 now equals 'three'
    callback(null, 'done');
}
</code></pre>
<h4 id="whilsttest-iteratee-callbackopt"><code>whilst(test, iteratee, callbackopt)</code></h4>
<p>只要检查通过就执行</p>
<p>实例：</p>
<pre><code class="language-js">var count = 0;
async.whilst(
    function() { return count &lt; 5; },
    function(callback) {
        count++;
        setTimeout(function() {
            callback(null, count);
        }, 1000);
    },
    function (err, n) {
        // 5 seconds have passed, n = 5
    }
);
</code></pre>
<h2 id="asyncjs常用工具类方法"><code>Async.js</code>常用工具类方法</h2>
<h4 id="applyfn"><code>apply(fn)</code></h4>
<p>创建一个函数，并传入参数或者在随后持续传入参数</p>
<p>实例：</p>
<pre><code class="language-js">// using apply
async.parallel([
    async.apply(fs.writeFile, 'testfile1', 'test1'),
    async.apply(fs.writeFile, 'testfile2', 'test2')
]);
// the same process without using apply
async.parallel([
    function(callback) {
        fs.writeFile('testfile1', 'test1', callback);
    },
    function(callback) {
        fs.writeFile('testfile2', 'test2', callback);
    }
]);
// It's possible to pass any number of additional arguments when calling the
// continuation:

node&gt; var fn = async.apply(sys.puts, 'one');
node&gt; fn('two', 'three');
one
two
three
</code></pre>
<h4 id="asyncifyfunc"><code>asyncify(func)</code></h4>
<p>将同步函数变为异步函数</p>
<p>实例：</p>
<pre><code class="language-js">// passing a regular synchronous function
async.waterfall([
    async.apply(fs.readFile, filename, &quot;utf8&quot;),
    async.asyncify(JSON.parse),
    function (data, next) {
        // data is the result of parsing the text.
        // If there was a parsing error, it would have been caught.
    }
], callback);
// passing a function returning a promise
async.waterfall([
    async.apply(fs.readFile, filename, &quot;utf8&quot;),
    async.asyncify(function (contents) {
        return db.model.create(contents);
    }),
    function (model, next) {
        // `model` is the instantiated model object.
        // If there was an error, this function would be skipped.
    }
], callback);
// es2017 example, though `asyncify` is not needed if your JS environment
// supports async functions out of the box
var q = async.queue(async.asyncify(async function(file) {
    var intermediateStep = await processFile(file);
    return await somePromise(intermediateStep)
}));
q.push(files);
</code></pre>
<h4 id="constant"><code>constant()</code></h4>
<p>返回一个函数，当调用时会返回给定的值</p>
<p>实例：</p>
<pre><code class="language-js">async.waterfall([
    async.constant(42),
    function (value, next) {
        // value === 42
    },
    //...
], callback);
async.waterfall([
    async.constant(filename, &quot;utf8&quot;),
    fs.readFile,
    function (fileData, next) {
        //...
    }
    //...
], callback);
async.auto({
    hostname: async.constant(&quot;https://server.net/&quot;),
    port: findFreePort,
    launchServer: [&quot;hostname&quot;, &quot;port&quot;, function (options, cb) {
        startServer(options, cb);
    }],
    //...
}, callback);
</code></pre>
<h4 id="dirfunction"><code>dir(function)</code></h4>
<p>使用<code>console.dir</code>打印出异步的函数的执行结果</p>
<p>实例：</p>
<pre><code class="language-js">// in a module
var hello = function(name, callback) {
    setTimeout(function() {
        callback(null, {hello: name});
    }, 1000);
};
// in the node repl
node&gt; async.dir(hello, 'world');
{hello: 'world'}
</code></pre>
<h4 id="ensureasyncfn"><code>ensureAsync(fn)</code></h4>
<p>包裹一个异步函数，使得它的回调函数在事件循环机制的下一个tick执行，通常是为了防止堆栈溢出</p>
<p>实例：</p>
<pre><code class="language-js">function sometimesAsync(arg, callback) {
    if (cache[arg]) {
        return callback(null, cache[arg]); // this would be synchronous!!
    } else {
        doSomeIO(arg, callback); // this IO would be asynchronous
    }
}
// this has a risk of stack overflows if many results are cached in a row
async.mapSeries(args, sometimesAsync, done);
// this will defer sometimesAsync's callback if necessary,
// preventing stack overflows
async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
</code></pre>
<h4 id="logfunction"><code>log(function)</code></h4>
<p>使用<code>console.log</code>打印出异步函数的执行结果</p>
<p>实例：</p>
<pre><code class="language-js">// in a module
var hello = function(name, callback) {
    setTimeout(function() {
        callback(null, 'hello ' + name);
    }, 1000);
};
// in the node repl
node&gt; async.log(hello, 'world');
'hello world'
</code></pre>
<h4 id="memoizefn-hasher"><code>memoize(fn, hasher)</code></h4>
<p>缓存异步函数的执行结果</p>
<p>实例：</p>
<pre><code class="language-js">var slow_fn = function(name, callback) {
    // do something
    callback(null, result);
};
var fn = async.memoize(slow_fn);
// fn can now be used as if it were slow_fn
fn('some name', function() {
    // callback
});
</code></pre>
<h4 id="nexttickcallback"><code>nextTick(callback)</code></h4>
<p>在事件循环之后的循环之中调用</p>
<p>实例：</p>
<pre><code class="language-js">var call_order = [];
async.nextTick(function() {
    call_order.push('two');
    // call_order now equals ['one','two']
});
call_order.push('one');
async.setImmediate(function (a, b, c) {
    // a, b, and c equal 1, 2, and 3
}, 1, 2, 3);
</code></pre>
<h4 id="reflectfn"><code>reflect(fn)</code></h4>
<p>包裹一个异步函数，不论是否执行成功总返回一个结果对象</p>
<p>实例：</p>
<pre><code class="language-js">async.parallel([
    async.reflect(function(callback) {
        // do some stuff ...
        callback(null, 'one');
    }),
    async.reflect(function(callback) {
        // do some more stuff but error ...
        callback('bad stuff happened');
    }),
    async.reflect(function(callback) {
        // do some more stuff ...
        callback(null, 'two');
    })
],
// optional callback
function(err, results) {
    // values
    // results[0].value = 'one'
    // results[1].error = 'bad stuff happened'
    // results[2].value = 'two'
});
</code></pre>
<h4 id="reflectalltasks"><code>reflectAll(tasks)</code></h4>
<p><code>reflect</code>的包裹数组或多个函数版</p>
<p>实例：</p>
<pre><code class="language-js">let tasks = [
    function(callback) {
        setTimeout(function() {
            callback(null, 'one');
        }, 200);
    },
    function(callback) {
        // do some more stuff but error ...
        callback(new Error('bad stuff happened'));
    },
    function(callback) {
        setTimeout(function() {
            callback(null, 'two');
        }, 100);
    }
];

async.parallel(async.reflectAll(tasks),
// optional callback
function(err, results) {
    // values
    // results[0].value = 'one'
    // results[1].error = Error('bad stuff happened')
    // results[2].value = 'two'
});

// an example using an object instead of an array
let tasks = {
    one: function(callback) {
        setTimeout(function() {
            callback(null, 'one');
        }, 200);
    },
    two: function(callback) {
        callback('two');
    },
    three: function(callback) {
        setTimeout(function() {
            callback(null, 'three');
        }, 100);
    }
};

async.parallel(async.reflectAll(tasks),
// optional callback
function(err, results) {
    // values
    // results.one.value = 'one'
    // results.two.error = 'two'
    // results.three.value = 'three'
});
</code></pre>
<h4 id="setimmediatecallback"><code>setImmediate(callback)</code></h4>
<p>在事件循环之后的循环之中调用</p>
<p>实例：</p>
<pre><code class="language-js">var call_order = [];
async.nextTick(function() {
    call_order.push('two');
    // call_order now equals ['one','two']
});
call_order.push('one');
async.setImmediate(function (a, b, c) {
    // a, b, and c equal 1, 2, and 3
}, 1, 2, 3);
</code></pre>
<h4 id="timeoutasyncfn-milliseconds-infoopt"><code>timeout(asyncFn, milliseconds, infoopt)</code></h4>
<p>如果异步函数在规定时间内还没有调用它的回调函数，则返回超时错误</p>
<p>实例：</p>
<pre><code class="language-js">function myFunction(foo, callback) {
    doAsyncTask(foo, function(err, data) {
        // handle errors
        if (err) return callback(err);

        // do some stuff ...

        // return processed data
        return callback(null, data);
    });
}
var wrapped = async.timeout(myFunction, 1000);
// call `wrapped` as you would `myFunction`
wrapped({ bar: 'bar' }, function(err, data) {
    // if `myFunction` takes &lt; 1000 ms to execute, `err`
    // and `data` will have their expected values
    // else `err` will be an Error with the code 'ETIMEDOUT'
});
</code></pre>
<h4 id="unmemoizefn"><code>unmemoize(fn)</code></h4>
<p>取消<code>memoize</code>缓存，将之转换为原值</p>
<h2 id="常见问题">常见问题</h2>
<h4 id="1-同步迭代器">1. 同步迭代器</h4>
<p>当你使用同步迭代器的时候，很有可能会遇到这个错误<code>RangeError: Maximum call stack size exceeded.</code>，只需使用<code>async.setImmediate</code>或者使用<code>async.ensureAsync</code>即可。</p>
<p>原代码：</p>
<pre><code class="language-js">async.eachSeries(hugeArray, function iteratee(item, callback) {
    if (inCache(item)) {
        callback(null, cache[item]); //如果缓存很多，则会内存溢出
    } else {
        doSomeIO(item, callback);
    }
}, function done() {
    //...
});
</code></pre>
<p>将之改为：</p>
<pre><code class="language-js">async.eachSeries(hugeArray, function iteratee(item, callback) {
    if (inCache(item)) {
        async.setImmediate(function() {
            callback(null, cache[item]);
        });
    } else {
        doSomeIO(item, callback);
        //...
    }
});
</code></pre>
<h4 id="2-多个回调">2. 多个回调</h4>
<p>确保在提前调用回调的时候加上<code>return</code>，例如：<code>return callback(err, result)</code>,否则将会导致回调函数多次被调用：</p>
<pre><code class="language-js">async.waterfall([
    function(callback) {
        getSomething(options, function (err, result) {
            if (err) {
                callback(new Error(&quot;failed getting something:&quot; + err.message));
                // 这里应该return
            }
            // 由于我们没有使用return，该回调还是会被调用，`processData`会被调用2次
            callback(null, result);
        });
    },
    processData
], done)
</code></pre>
<h4 id="3-使用es2017async函数">3. 使用ES2017<code>async</code>函数</h4>
<p>在<code>Async.js</code>中使用ES2017的async函数的时候，不会传递回调函数，并且只能接受原生的async函数而不是经过babel转化过得，你也可以使用<code>async.asyncify()</code>进行包裹，而且只会使用返回的值或者处理Promise的rejections或者errors。</p>
<pre><code class="language-js">async.mapLimit(files, async file =&gt; { // 没有回调函数
    const text = await util.promisify(fs.readFile)(dir + file, 'utf8')
    const body = JSON.parse(text) // &lt;- 解析错误将会自动捕获
    if (!(await checkValidity(body))) {
        throw new Error(`${file} has invalid contents`) // &lt;- 这个错误也会自动捕获
    }
    return body // &lt;返回值
}, (err, contents) =&gt; {
    if (err) throw err
    console.log(contents)
})
</code></pre>
<h4 id="4-为迭代器绑定上下文">4. 为迭代器绑定上下文</h4>
<p><code>Async.js</code>迭代器执行的环境<code>this</code>其实指向的是global对象，想要改变迭代器的this指针，可以使用bind进行改变：</p>
<pre><code class="language-js">// Here is a simple object with an (unnecessarily roundabout) squaring method
var AsyncSquaringLibrary = {
    squareExponent: 2,
    square: function(number, callback){
        var result = Math.pow(number, this.squareExponent);
        setTimeout(function(){
            callback(null, result);
        }, 200);
    }
};

async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result) {
    // result is [NaN, NaN, NaN]
});

async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result) {
    // result is [1, 4, 9]
});
Down
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://caolan.github.io/async/docs.html#concat" target="_blank" rel="nofollow">Async.js官方文档</a></li>
</ul>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://huxinmin.github.io/post/shi-yong-liu-lan-qi-cha-jian-video-downloader-xia-zai-youtubebi-li-bi-li-you-ku-deng-ge-da-shi-pin-wang-zhan-de-shi-pin/">
                                    <h3 class="post-title">
                                        使用浏览器插件Video Downloader下载youtube，哔哩哔哩，优酷等各大视频网站的视频
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
        <a href="#!" id="tool-toc" class="hidden-xs hidden-sm">
            <i class="fa fa-map"></i>
        </a>
        <br>
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#asyncjs%E4%BB%8B%E7%BB%8D"><code>Async.js</code>介绍</a></li>
<li><a href="#asyncjs%E5%AE%89%E8%A3%85"><code>Async.js</code>安装</a></li>
<li><a href="#asyncjs%E9%9B%86%E5%90%88%E7%B1%BB%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><code>Async.js</code>集合类操作方法</a><br>
*
<ul>
<li><a href="#concatcoll-iteratee-callbackerropt"><code>concat(coll, iteratee, callback(err)opt)</code></a></li>
<li><a href="#concatlimitcoll-limit-iteratee-callbackopt"><code>concatLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#concatseriescoll-iteratee-callbackerropt"><code>concatSeries(coll, iteratee, callback(err)opt)</code></a></li>
<li><a href="#detectcoll-iteratee-callbackopt"><code>detect(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#detectlimitcoll-limit-iteratee-callbackopt"><code>detectLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#detectseriescoll-iteratee-callbackopt"><code>detectSeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#eachcoll-iteratee-callbackopt"><code>each(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#eachlimitcoll-limit-iteratee-callbackopt"><code>eachLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#eachseriescoll-iteratee-callbackopt"><code>eachSeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#eachofcoll-iteratee-callbackopt"><code>eachOf(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#eachoflimitcoll-limit-iteratee-callbackopt"><code>eachOfLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#eachofseriescoll-iteratee-callbackopt"><code>eachOfSeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#everycoll-iteratee-callbackopt"><code>every(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#everylimitcoll-limit-iteratee-callbackopt"><code>everyLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#everyseriescoll-iteratee-callbackopt"><code>everySeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#filtercoll-iteratee-callbackopt"><code>filter(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#filterlimitcoll-limit-iteratee-callbackopt"><code>filterLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#filterseriescoll-iteratee-callbackopt"><code>filterSeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#groupbycoll-iteratee-callbackopt"><code>groupBy(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#groupbylimitcoll-limit-iteratee-callbackopt"><code>groupByLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#groupbyseriescoll-limit-iteratee-callbackopt"><code>groupBySeries(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#mapcoll-iteratee-callbackopt"><code>map(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#maplimitcoll-limit-iteratee-callbackopt"><code>mapLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#mapseriescoll-iteratee-callbackopt"><code>mapSeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#mapvaluesobj-iteratee-callbackopt"><code>mapValues(obj, iteratee, callbackopt)</code></a></li>
<li><a href="#mapvalueslimitobj-limit-iteratee-callbackopt"><code>mapValuesLimit(obj, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#mapvaluesseriesobj-iteratee-callbackopt"><code>mapValuesSeries(obj, iteratee, callbackopt)</code></a></li>
<li><a href="#reducecoll-memo-iteratee-callbackopt"><code>reduce(coll, memo, iteratee, callbackopt)</code></a></li>
<li><a href="#reducerightarray-memo-iteratee-callbackopt"><code>reduceRight(array, memo, iteratee, callbackopt)</code></a></li>
<li><a href="#rejectcoll-iteratee-callbackopt"><code>reject(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#rejectlimitcoll-limit-iteratee-callbackopt"><code>rejectLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#rejectseriescoll-iteratee-callbackopt"><code>rejectSeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#somecoll-iteratee-callbackopt"><code>some(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#somelimitcoll-limit-iteratee-callbackopt"><code>someLimit(coll, limit, iteratee, callbackopt)</code></a></li>
<li><a href="#someseriescoll-iteratee-callbackopt"><code>someSeries(coll, iteratee, callbackopt)</code></a></li>
<li><a href="#sortbycoll-iteratee-callback"><code>sortBy(coll, iteratee, callback)</code></a></li>
<li><a href="#transformcoll-accumulatoropt-iteratee-callbackopt"><code>transform(coll, accumulatoropt, iteratee, callbackopt)</code></a></li>
</ul>
</li>
<li><a href="#asyncjs%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><code>Async.js</code>流程控制方法</a><br>
*
<ul>
<li><a href="#applyeachfns-argsopt-callbackopt"><code>applyEach(fns, …argsopt, callbackopt)</code></a></li>
<li><a href="#applyeachseriesfns-argsopt-callbackopt"><code>applyEachSeries(fns, …argsopt, callbackopt)</code></a></li>
<li><a href="#autotasks-concurrencyopt-callbackopt"><code>auto(tasks, concurrencyopt, callbackopt)</code></a></li>
<li><a href="#autoinjecttasks-callbackopt"><code>autoInject(tasks, callbackopt)</code></a></li>
<li><a href="#cargoworker-payloadopt"><code>cargo(worker, payloadopt)</code></a></li>
<li><a href="#composefunctions"><code>compose(…functions)</code></a></li>
<li><a href="#doduringfn-test-callbackopt"><code>doDuring(fn, test, callbackopt)</code></a></li>
<li><a href="#dountiliteratee-test-callbackopt"><code>doUntil(iteratee, test, callbackopt)</code></a></li>
<li><a href="#dowhilstiteratee-test-callbackopt"><code>doWhilst(iteratee, test, callbackopt)</code></a></li>
<li><a href="#duringtest-fn-callbackopt"><code>during(test, fn, callbackopt)</code></a></li>
<li><a href="#foreverfn-errbackopt"><code>forever(fn, errbackopt)</code></a></li>
<li><a href="#paralleltasks-callbackopt"><code>parallel(tasks, callbackopt)</code></a></li>
<li><a href="#parallellimittasks-limit-callbackopt"><code>parallelLimit(tasks, limit, callbackopt)</code></a></li>
<li><a href="#priorityqueueworker-concurrency"><code>priorityQueue(worker, concurrency)</code></a></li>
<li><a href="#queueworker-concurrencyopt"><code>queue(worker, concurrencyopt)</code></a></li>
<li><a href="#racetasks-callback"><code>race(tasks, callback)</code></a></li>
<li><a href="#retryoptsopt-task-callbackopt"><code>retry(optsopt, task, callbackopt)</code></a></li>
<li><a href="#retryableoptsopt-task"><code>retryable(optsopt, task)</code></a></li>
<li><a href="#seqfunctions"><code>seq(…functions)</code></a></li>
<li><a href="#seriestasks-callbackopt"><code>series(tasks, callbackopt)</code></a></li>
<li><a href="#timesn-iteratee-callback"><code>times(n, iteratee, callback)</code></a></li>
<li><a href="#timeslimitcount-limit-iteratee-callback"><code>timesLimit(count, limit, iteratee, callback)</code></a></li>
<li><a href="#timesseriesn-iteratee-callback"><code>timesSeries(n, iteratee, callback)</code></a></li>
<li><a href="#tryeachtasks-callbackopt"><code>tryEach(tasks, callbackopt)</code></a></li>
<li><a href="#untiltest-iteratee-callbackopt"><code>until(test, iteratee, callbackopt)</code></a></li>
<li><a href="#waterfalltasks-callbackopt"><code>waterfall(tasks, callbackopt)</code></a></li>
<li><a href="#whilsttest-iteratee-callbackopt"><code>whilst(test, iteratee, callbackopt)</code></a></li>
</ul>
</li>
<li><a href="#asyncjs%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%96%B9%E6%B3%95"><code>Async.js</code>常用工具类方法</a><br>
*
<ul>
<li><a href="#applyfn"><code>apply(fn)</code></a></li>
<li><a href="#asyncifyfunc"><code>asyncify(func)</code></a></li>
<li><a href="#constant"><code>constant()</code></a></li>
<li><a href="#dirfunction"><code>dir(function)</code></a></li>
<li><a href="#ensureasyncfn"><code>ensureAsync(fn)</code></a></li>
<li><a href="#logfunction"><code>log(function)</code></a></li>
<li><a href="#memoizefn-hasher"><code>memoize(fn, hasher)</code></a></li>
<li><a href="#nexttickcallback"><code>nextTick(callback)</code></a></li>
<li><a href="#reflectfn"><code>reflect(fn)</code></a></li>
<li><a href="#reflectalltasks"><code>reflectAll(tasks)</code></a></li>
<li><a href="#setimmediatecallback"><code>setImmediate(callback)</code></a></li>
<li><a href="#timeoutasyncfn-milliseconds-infoopt"><code>timeout(asyncFn, milliseconds, infoopt)</code></a></li>
<li><a href="#unmemoizefn"><code>unmemoize(fn)</code></a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a><br>
*
<ul>
<li><a href="#1-%E5%90%8C%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8">1. 同步迭代器</a></li>
<li><a href="#2-%E5%A4%9A%E4%B8%AA%E5%9B%9E%E8%B0%83">2. 多个回调</a></li>
<li><a href="#3-%E4%BD%BF%E7%94%A8es2017async%E5%87%BD%E6%95%B0">3. 使用ES2017<code>async</code>函数</a></li>
<li><a href="#4-%E4%B8%BA%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%91%E5%AE%9A%E4%B8%8A%E4%B8%8B%E6%96%87">4. 为迭代器绑定上下文</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>

</div>


    
<footer id="fh5co-footer">
  <p>Powered by <a href="https://huxinmin.github.io" target="_blank">胡新敏的个人博客</a></p>
</footer>


    <!-- jQuery -->
<script src="https://huxinmin.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://huxinmin.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://huxinmin.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://huxinmin.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://huxinmin.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://huxinmin.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://huxinmin.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
        var allImg = $("img");
        allImg.on("contextmenu", function () {
            return false;
        });
        allImg.on("dragstart", function () {
            return false;
        });
    
</script>




</body>
</html>
