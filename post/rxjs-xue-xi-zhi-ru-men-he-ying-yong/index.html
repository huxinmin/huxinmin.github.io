<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>胡新敏的个人博客</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="胡新敏的个人博客"/>
<meta name="keywords" content="胡新敏的个人博客"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://huxinmin.github.io/favicon.ico">

<link rel="stylesheet" href="https://huxinmin.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://huxinmin.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://huxinmin.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://huxinmin.github.io/images/avatar.png" alt="胡新敏的个人博客"
                 class="img-responsive">
        </figure>
        <a href="https://huxinmin.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>胡新敏的个人博客</h2>
        <p>胡新敏的个人博客</p>
        <ul class="fh5co-social">
            
                <li>
                    
                        <a href="https://github.com/huxinmin" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                        <a href="https://www.zhihu.com/people/hu-xin-min-99" target="_blank">
                            <i class="fab fa-zhihu"></i>
                        </a>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://huxinmin.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://huxinmin.github.io/tag/mSeB0wbbH/">linux</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/0CEgc5Nuc/">react</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/7tyyR9fOk/">ja</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/AzH6zVqFK/">js</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/UJq-iLfq6/">restful</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/r0zynGCMV/">http</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/GNbObqsVG/">json</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/dZU9srOJ4/">moment.js</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/wsD4ABEPz/">数据库</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/tq8jF2xcA/">mongoose</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/VL5yScL71/">mongodb</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/XRK7arMJO/">nodejs</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/DJMLUSVfi/">html5</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/oHlYLx_Tl/">websocket</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/8-tAS0eFO/">nginx</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/X3jlBk5nJ/">css</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/H8XsrzQ7e/">css3</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/J27JVlP2F/">文件上传</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/X3Z7s8kF_/">jquery</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/CrwH886ky/">ajax</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/s0bxFP3uF/">express</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/ZSDYSDwY2/">其他</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/4OX23_HC0/">jest</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/JavlGTiRY/">editorconfig</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/pTofQIx8N/">待办事宜</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/8u7cjaUBn/">随笔</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/knySerdH-/">git</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/NSyjPJZkv/">aws</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/pU8c2aJR5/">webassembly</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/UsaB01y9b/">sublime</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/oVWhBDgSF/">centos</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/JqHVZntTk/">putty</a></li>
                
                    <li><a href="https://huxinmin.github.io/tag/HOjS4qCUx/">npm</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            标签
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            关于
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://huxinmin.github.io">胡新敏的个人博客 </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
            </span>
            <h2 class="fh5co-article-title animate-box">Rxjs学习之入门和应用</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2020-04-20</li>
                <li>4962字</li>
                <li>20 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <h2 id="rxjs简介">Rxjs简介</h2>
<p>RxJS是ReactiveX编程理念的JavaScript版本。ReactiveX来自微软，它是一种针对异步数据流的编程。简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装成流的形式，然后用强大丰富的操作符对流进行处理，使你能以同步编程的方式处理异步数据，并组合不同的操作符来轻松优雅的实现你所需要的功能。</p>
<h2 id="reactivex简介">Reactivex简介</h2>
<p>ReactiveX 是一个基于一系列可观察的异步和基础事件编程组成的一个库。</p>
<p>它继承观察者模式，支持序列数据或者事件。更高级的用法允许你将如下的一些抽象概念操作一起联合使用，比如低线程，同步，线程安全，数据并发，非阻塞I/O流。</p>
<p>它通常被称为“函数响应式编程”，这是用词不当的。ReactiveX 可以是函数式的，可以是响应式的，但是和“函数响应式编程”是不同的概览。一个主要的不同点是“函数响应式编程”是对随着时间不停变化的值进行操作的，而ReactiveX是对超时提交产生的离散值上。</p>
<h2 id="why-rxjs">Why Rxjs</h2>
<p>我们可能会问自己，为什么使用RxJS?不是有Promise吗？没错，Promise对于只期望单值返回的异步请求（比如：XMLHttpRequest）是一个好的解决方案。但Reactive Extensions for JavaScript对Promises, callbacks , Web Workers, Web Sockets进行了统一优化. 一旦我们统一优化这一些概念后，我们将能更好的进行开发。</p>
<p>为了更好的理解，请看下面的这个例子：<br>
搜索是前端开发中很常见的功能，一般是监听<code>&lt;input /&gt;</code>的keyup事件，然后将内容发送到后台，并展示后台返回的数据。</p>
<pre><code class="language-html">&lt;input id=&quot;text&quot;&gt;&lt;/input&gt;
&lt;script&gt;
    var text = document.querySelector('#text');
    text.addEventListener('keyup', (e) =&gt;{
        var searchText = e.target.value;
        // 发送输入内容到后台
        $.ajax({
            url: `/search/${searchText}`,
            success: data =&gt; {
              // 拿到后台返回数据，并展示搜索结果
              render(data);
            }
        });
    });
&lt;/script&gt;
</code></pre>
<p>上面代码实现我们要的功能，但存在两个较大的问题：</p>
<ul>
<li>
<h4 id="多余的请求">多余的请求</h4>
</li>
</ul>
<p>当想搜索“爱迪生”时，输入框可能会存在三种情况，“爱”、“爱迪”、“爱迪生”。而这三种情况将会发起 3 次请求，存在 2 次多余的请求。</p>
<ul>
<li>
<h4 id="已无用的请求仍然执行">已无用的请求仍然执行</h4>
</li>
</ul>
<p>一开始搜了“爱迪生”，然后马上改搜索“达尔文”。结果后台返回了“爱迪生”的搜索结果，执行渲染逻辑后结果框展示了“爱迪生”的结果，而不是当前正在搜索的“达尔文”，这是不正确的。</p>
<p>减少多余请求数，可以用 <code>setTimeout</code> 函数节流的方式来处理，核心代码如下：</p>
<pre><code class="language-html">&lt;input id=&quot;text&quot;&gt;&lt;/input&gt;
&lt;script&gt;
    var text = document.querySelector('#text'),
        timer = null;
    text.addEventListener('keyup', (e) =&gt;{
        // 在 250 毫秒内进行其他输入，则清除上一个定时器
        clearTimeout(timer);
        // 定时器，在 250 毫秒后触发
        timer = setTimeout(() =&gt; {
            console.log('发起请求..');
        },250)
    })
&lt;/script&gt;
</code></pre>
<p>已无用的请求仍然执行 的解决方式，可以在发起请求前声明一个当前搜索的状态变量，后台将搜索的内容及结果一起返回，前端判断返回数据与当前搜索是否一致，一致才走到渲染逻辑。最终代码为：</p>
<pre><code class="language-html">&lt;input id=&quot;text&quot;&gt;&lt;/input&gt;
&lt;script&gt;
    var text = document.querySelector('#text'),
        timer = null,
        currentSearch = '';

    text.addEventListener('keyup', (e) =&gt;{
        clearTimeout(timer)
        timer = setTimeout(() =&gt; {
            // 声明一个当前所搜的状态变量
            currentSearch ＝ '书'; 

            var searchText = e.target.value;
            $.ajax({
                url: `/search/${searchText}`,
                success: data =&gt; {
                    // 判断后台返回的标志与我们存的当前搜索变量是否一致
                    if (data.search === currentSearch) {
                        // 渲染展示
                        render(data);
                    } else {
                        // ..
                    }
                }           
            });
        },250)
    })
&lt;/script&gt;
</code></pre>
<p>上面代码基本满足需求，但代码开始显得乱糟糟。我们来使用RxJS实现上面代码功能，如下:</p>
<pre><code class="language-js">var text = document.querySelector('#text');
var inputStream = Rx.Observable.fromEvent(text, 'keyup')
                    .debounceTime(250)
                    .pluck('target', 'value')
                    .switchMap(url =&gt; Http.get(url))
                    .subscribe(data =&gt; render(data));
</code></pre>
<p>RxJS能简化你的代码，它将与流有关的内部状态封装在流中，而不需要在流外定义各种变量来以一种上帝视角控制流程。Rx的编程方式使你的业务逻辑流程清晰，易维护，并显著减少出bug的概率。</p>
<h2 id="安装方法">安装方法</h2>
<ul>
<li>
<h4 id="通过-npm-安装-es6-版本">通过 npm 安装 ES6 版本</h4>
</li>
</ul>
<pre><code class="language-js">npm install rxjs
</code></pre>
<p>导入整个核心功能集：</p>
<pre><code class="language-js">import Rx from 'rxjs/Rx';
Rx.Observable.of(1,2,3)
</code></pre>
<p>通过打补丁的方式只导入所需要的(这对于减少 bundling 的体积是十分有用的)：</p>
<pre><code class="language-js">import { Observable} from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';
Observable.of(1,2,3).map(x =&gt; x + '!!!'); // 等等
</code></pre>
<p>只导入需要的并且使用被提议的绑定操作符：<br>
注意：这个额外的预发需要编译器支持并且此语法可能会在没有任何通知的情况下完全从 TC39 撤回！要使用的话需要你自己来承担风险。</p>
<pre><code class="language-js">import { Observable } from 'rxjs/Observable';
import { of } from 'rxjs/observable/of';
import { map } from 'rxjs/operator/map';
Observable::of(1,2,3)::map(x =&gt; x + '!!!'); // 等等
</code></pre>
<ul>
<li>
<h4 id="通过-npm-安装-commonjs-版本">通过 npm 安装 CommonJS 版本</h4>
</li>
</ul>
<pre><code class="language-js">npm install rxjs
</code></pre>
<p>导入所有核心功能:</p>
<pre><code class="language-js">var Rx = require('rxjs/Rx');
Rx.Observable.of(1,2,3); // 等等
</code></pre>
<p>通过打补丁的方式只导入所需要的(这对于减少 bundling 的体积是十分有用的)：</p>
<pre><code class="language-js">var Observable = require('rxjs/Observable').Observable;
// 使用适合的方法在 Observable 上打补丁
require('rxjs/add/observable/of');
require('rxjs/add/operator/map');
Observable.of(1,2,3).map(function (x) { return x + '!!!'; }); // 等等
</code></pre>
<p>导入操作符并手动地使用它们(这对于减少 bundling 的体积也十分有用)：</p>
<pre><code class="language-js">var of = require('rxjs/observable/of').of;
var map = require('rxjs/operator/map').map;
map.call(of(1,2,3), function (x) { return x + '!!!'; });
</code></pre>
<p>还可以使用上面的方法来构建你自己的 Observable 并将其从你自己的模块中导出。</p>
<ul>
<li>
<h4 id="使用-typescript-的-commonjs-模式">使用 TypeScript 的 CommonJS 模式</h4>
</li>
</ul>
<p>当使用 RxJS 时收到了像 error TS2304: Cannot find name 'Promise' 或 error TS2304: Cannot find name 'Iterable' 这样的报错信息，那么你可能需要安装额外的 typings 。<br>
对于使用 typings 的用户:</p>
<pre><code class="language-js">typings install es6-shim --ambient
</code></pre>
<p>如果没有使用 typings 的话，可以从 <code>/es6-shim/es6-shim.d.ts</code> 拷贝定义好的接口。<br>
在 <code>tsconfig.json</code> 或 CLI 参数中添加类型定义文件。</p>
<ul>
<li>
<h4 id="通过-npm-所有全模块类型-cjses6amdtypescript">通过 npm 所有全模块类型 (CJS/ES6/AMD/TypeScript)</h4>
</li>
</ul>
<p>要安装这个库需要 npm 3及以上版本，使用下面的命令行：</p>
<pre><code class="language-js">npm install @reactivex/rxjs
</code></pre>
<p>如果你使用的还是 npm 2的话，那么在这个库升级至稳定版之前，需要明确地指定库的版本号：</p>
<pre><code class="language-js">npm install @reactivex/rxjs@5.0.0-beta.1
</code></pre>
<ul>
<li>
<h4 id="cdn">CDN</h4>
</li>
</ul>
<p>对于 CDN，可以使用 BootCDN。只需要用当前的版本号来替换下面链接中的 version：</p>
<pre><code class="language-js">https://cdn.bootcss.com/rxjs/6.0.0-beta.3/rxjs.umd.min.js
</code></pre>
<h2 id="核心概念">核心概念</h2>
<ul>
<li>
<h4 id="stream"><code>Stream</code></h4>
</li>
</ul>
<p>流是在时间流逝的过程中产生的一系列事件。它具有时间与事件响应的概念。<br>
我们可以把一切输入都当做数据流来处理，比如说：<br>
- 用户操作<br>
- 网络响应<br>
- 定时器<br>
- Worker</p>
<ul>
<li>
<h4 id="observable"><code>Observable</code></h4>
</li>
</ul>
<p>可观察序列，简单来说数据就在Observable中流动，你可以使用各种operator对流进行处理</p>
<ul>
<li>
<h4 id="observer"><code>Observer</code></h4>
</li>
</ul>
<p>observer（观察者），表示的是对序列结果的处理方式</p>
<ul>
<li>
<h4 id="operator"><code>Operator</code></h4>
</li>
</ul>
<p>操作符（纯函数）</p>
<ul>
<li>
<h4 id="subject"><code>Subject</code></h4>
</li>
</ul>
<p>Subject是一种能够发射数据给多个observer的Observable, 这让Subject看起来就好像是EventEmitter。</p>
<ul>
<li>
<h4 id="scheduers"><code>Scheduers</code></h4>
</li>
</ul>
<p>调度器, 控制并发行为</p>
<ul>
<li>
<h4 id="subscription"><code>Subscription</code></h4>
</li>
</ul>
<p>订阅器，Observable动作执行者</p>
<h2 id="模式">模式</h2>
<p>RxJS是基于观察者模式，迭代器模式和函数式编程:</p>
<ul>
<li>
<h4 id="观察者模式">观察者模式</h4>
</li>
</ul>
<pre><code class="language-js">window.addEventListener('click', function(){
  console.log('click!');
})
</code></pre>
<p>JS的事件监听就是天生的观察者模式。给window的click事件(被观察者)绑定了一个listener(观察者)，当事件发生，回调函数就会被触发</p>
<ul>
<li>
<h4 id="迭代器模式">迭代器模式</h4>
</li>
</ul>
<p>迭代器模式，提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。<br>
ES6里的Iterator即可实现：</p>
<pre><code class="language-js">let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();
iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
</code></pre>
<ul>
<li>
<h4 id="函数式编程">函数式编程</h4>
</li>
</ul>
<p>提到函数式编程，就要提到声明式编程和命令式编程<br>
函数式编程是声明式编程的体现<br>
问题：将数组[1, 2, 3]的每个元素乘以2，然后计算总和。<br>
- 命令式编程</p>
<pre><code class="language-js">const arr = [1, 2, 3];
let total = 0;
for(let i = 0; i &lt; arr.length; i++) {
  total += arr[i] * 2;
}
</code></pre>
<pre><code>- 声明式编程
</code></pre>
<pre><code class="language-js">const arr = [1, 2, 3];
let total = arr.map(x =&gt; x * 2).reduce((total, value) =&gt; total + value)
</code></pre>
<p>声明式的特点是专注于描述结果本身，不关注到底怎么到达结果。而命令式就是真正实现结果的步骤</p>
<p>声明式编程把原始数据经过一系列转换(map, reduce)，最后得到想要的数据</p>
<p>现在前端流行的MVC框架(Vue,React,Angular)，也都是提倡：编写UI结构时使用声明式编程，在编写业务逻辑时使用命令式编程</p>
<h2 id="开始使用">开始使用</h2>
<ul>
<li>
<h4 id="创建可观察序列">创建可观察序列</h4>
</li>
</ul>
<p>创建一个序列有很多种方式，我们仅列举常用的几种：</p>
<pre><code class="language-js">Observable.of(...args)
</code></pre>
<p>将普通JavaScript数据转为可观察序列。</p>
<pre><code class="language-js">Observable.fromPromise(promise)
</code></pre>
<p>将Promise转化为Observable。</p>
<pre><code class="language-js">Observable.fromEvent(elment, eventName)
</code></pre>
<p>从DOM事件创建序列，例如Observable.fromEvent($input, 'click')。</p>
<pre><code class="language-js">Observable.ajax(url | AjaxRequest)
</code></pre>
<p>发送http请求，AjaxRequest</p>
<pre><code class="language-js">Observable.create(subscribe)
</code></pre>
<p>这个属于万能的创建方法，很少会用到，在你用这个方法之前先想想能不能用RxJS上的类方法来创建你所需要的序列。</p>
<ul>
<li>
<h4 id="合并序列">合并序列</h4>
</li>
</ul>
<p>合并序列也属于创建序列的一种，例如有这样的需求：进入某个页面后拿到了一个列表，然后需要对列表每一项发出一个http请求来获取对应的详细信息，这里我们把每个http请求作为一个序列，然后我们希望合并它们。<br>
合并有很多种方式，例如N个请求按顺序串行发出（前一个结束再发下一个）；N个请求同时发出并且要求全部到达后合并为数组，触发一次回调；N个请求同时发出，对于每一个到达就触发一次回调。<br>
如果不用RxJS，我们会比较难处理这么多情形，不仅实现麻烦，维护更麻烦，下面是使用RxJS对上述需求的解决方案：</p>
<pre><code class="language-js">const ob1 = Observable.ajax('api/detail/1');
const ob2 = Observable.ajax('api/detail/2');
...
const obs = [ob1, ob2...];
// 分别创建对应的HTTP请求。
</code></pre>
<ul>
<li>N个请求按顺序串行发出（前一个结束再发下一个）</li>
</ul>
<pre><code class="language-js">Observable.concat(...obs).subscribe(detail =&gt; console.log('每个请求都触发回调'));
</code></pre>
<ul>
<li>N个请求同时并行发出，对于每一个到达就触发一次回调</li>
</ul>
<pre><code class="language-js">Observable.merge(...obs).subscribe(detail =&gt; console.log('每个请求都触发回调'));
</code></pre>
<ul>
<li>N个请求同时发出并且要求全部到达后合并为数组，触发一次回调</li>
</ul>
<pre><code class="language-js">Observable.forkJoin(...obs).subscribe(detailArray =&gt; console.log('触发一次回调'));
</code></pre>
<ul>
<li>
<h4 id="创建多路推送序列">创建多路推送序列</h4>
</li>
</ul>
<p>Subject是一种可以多路推送的可观察对象。与EventEmitter类似，Subject维护着自己的Observer。</p>
<p>每一个Subject都是一个Observable（可观察对象） 对于一个Subject，你可以订阅（subscribe）它，Observer会和往常一样接收到数据。从Observer的视角看，它并不能区分自己的执行环境是普通Observable的单路推送还是基于Subject的多路推送。</p>
<p>Subject的内部实现中，并不会在被订阅（subscribe）后创建新的执行环境。它仅仅会把新的Observer注册在由它本身维护的Observer列表中，这和其他语言、库中的addListener机制类似。</p>
<p>每一个Subject也可以作为Observer（观察者） Subject同样也是一个由next(v)，error(e)，和 complete()这些方法组成的对象。调用next(theValue)方法后，Subject会向所有已经在其上注册的Observer多路推送theValue。</p>
<p>下面的例子中，我们在Subject上注册了两个Observer，并且多路推送了一些数值：</p>
<pre><code class="language-js">var subject = new Rx.Subject();
subject.subscribe({
  next: (v) =&gt; console.log('observerA: ' + v)
});
subject.subscribe({
  next: (v) =&gt; console.log('observerB: ' + v)
});
subject.next(1);
subject.next(2);
</code></pre>
<p>控制台输出结果如下：</p>
<pre><code class="language-js">observerA: 1
observerB: 1
observerA: 2
observerB: 2
</code></pre>
<ul>
<li>
<h4 id="扁平化流">扁平化流</h4>
</li>
</ul>
<p>有时候，我们的Observable送出的是一个新的Observable:</p>
<pre><code class="language-js">var click = Rx.Observable.fromEvent(document.body, 'click');
var source = click.map(e =&gt; Rx.Observable.of(1, 2, 3));
source.subscribe(value =&gt; {
  console.log(value)
});
</code></pre>
<p>这里，console打印出来的是对象，而不是我们想要的1,2,3，这是因为map返回的Rx.Observable.of(1, 2, 3)本身也是个Observable</p>
<p>用图表示如下：</p>
<pre><code class="language-js">click  : ------c------------c--------
      map(e =&gt; Rx.Observable.of(1,2,3))
source : ------o------------o--------
              \            \
               (123)|       (123)|
</code></pre>
<p>因此，我们订阅到的value值就是一个Observable对象，而不是普通数据1，2，3</p>
<p>我想要的其实不是Observable本身，而是属于这个Observable里面的那些东西，现在这个情形就是Observable里面又有Observable，有两层，可是我想要让它变成一层就好，该怎么办呢？</p>
<p>这就需要把Observable扁平化</p>
<pre><code class="language-js">const arr = [1, [2, 3], 4];
// 扁平化后：
const flatArr = [1, 2, 3, 4];
</code></pre>
<p>concatAll这个操作符就可以把Observable扁平化</p>
<pre><code class="language-js">var click = Rx.Observable.fromEvent(document.body, 'click');
var source = click.map(e =&gt; Rx.Observable.of(1, 2, 3));
var example = source.concatAll();
example.subscribe(value =&gt; {
  console.log(value)
})
</code></pre>
<pre><code class="language-js">click  : ------c------------c--------
      map(e =&gt; Rx.Observable.of(1,2,3))
source : ------o------------o--------
              \            \
               (123)|       (123)|
                 concatAll()
example: ------(123)--------(123)------------
</code></pre>
<p>flatMap操作符也可以实现同样的作用，就是写法有些不同：</p>
<pre><code class="language-js">var click = Rx.Observable.fromEvent(document.body, 'click');
var source = click.flatMap(e =&gt; Rx.Observable.of(1, 2, 3));
source.subscribe(value =&gt; {
  console.log(value)
})
</code></pre>
<pre><code class="language-js">click  : ------c------------c--------
      flatMap(e =&gt; Rx.Observable.of(1,2,3))
source: ------(123)--------(123)------------
</code></pre>
<h2 id="常用操作符">常用操作符</h2>
<ul>
<li>
<h4 id="repeat"><code>repeat</code></h4>
</li>
</ul>
<p>重复 count 次，源 Observable 发出的值。</p>
<ul>
<li>
<h4 id="pip"><code>pip</code></h4>
</li>
<li>
<h4 id="map"><code>map</code></h4>
</li>
</ul>
<p>对 Observable 对象发出的每个值，使用指定的 project 函数，进行映射处理。</p>
<ul>
<li>
<h4 id="mapto"><code>mapTo</code></h4>
</li>
</ul>
<p>对 Observable 对象发出的每个值，映射成固定的值。</p>
<ul>
<li>
<h4 id="pluck"><code>pluck</code></h4>
</li>
</ul>
<p>提取属性值并输出</p>
<ul>
<li>
<h4 id="do"><code>do</code></h4>
</li>
</ul>
<p>不做数据格式化，可用于调试</p>
<ul>
<li>
<h4 id="filter"><code>filter</code></h4>
</li>
</ul>
<p>对 Observable 对象发出的每个值，作为参数调用指定的 predicate 函数，若该函数的返回值为 true，则表示保留该项，若返回值为 false，则舍弃该值。</p>
<ul>
<li>
<h4 id="take"><code>take</code></h4>
</li>
</ul>
<p>于获取 Observable 对象发出的前 n 项值，取完后就结束。</p>
<ul>
<li>
<h4 id="takewhile"><code>takeWhile</code></h4>
</li>
</ul>
<p>满足什么条件时开始取数据</p>
<ul>
<li>
<h4 id="skip"><code>skip</code></h4>
</li>
</ul>
<p>表示跳过多少条数据后开始取</p>
<ul>
<li>
<h4 id="distinctuntilchanged"><code>distinctUntilChanged</code></h4>
</li>
</ul>
<p>过滤源 Observable 发出的值，若当前发出的值与前一次值不一致，则发出该值。</p>
<ul>
<li>
<h4 id="scan"><code>scan</code></h4>
</li>
</ul>
<p>功能有点类似于Array#reduce这个方法，可用于累加数据同时可以使用startWith的数据用途scan的初始值，最后返回累加的数据</p>
<ul>
<li>
<h4 id="delay"><code>delay</code></h4>
</li>
</ul>
<p>表示Observable延时多久开始处理订阅数据</p>
<ul>
<li>
<h4 id="toarray"><code>toArray</code></h4>
</li>
</ul>
<p>把输出值格式化成数据形式</p>
<ul>
<li>
<h4 id="tomap"><code>toMap</code></h4>
</li>
</ul>
<p>给当前的输出取个名字或标签</p>
<ul>
<li>
<h4 id="expand"><code>expand</code></h4>
</li>
</ul>
<p>实现递归</p>
<ul>
<li>
<h4 id="forkjoin"><code>forkJoin</code></h4>
</li>
</ul>
<p>类似于Promise.all，只有数据全部返回且状态为complete时，表示成功处理了请求，否则失败</p>
<ul>
<li>
<h4 id="let"><code>let</code></h4>
</li>
</ul>
<p>这个操作符可以获取完整的输入Observable对象，做相应的处理后返回新的Observable对象</p>
<ul>
<li>
<h4 id="catch"><code>catch</code></h4>
</li>
</ul>
<p>用于Observable处理数据异常的处理</p>
<ul>
<li>
<h4 id="combinelatest"><code>combineLatest</code></h4>
</li>
</ul>
<p>用于组且各个输入的Observable，并获取和返回各个Observable最新的数据</p>
<ul>
<li>
<h4 id="buffer"><code>buffer</code></h4>
</li>
</ul>
<p>缓冲源 Observable 对象已发出的值，直到 closingNotifier 触发后，才统一输出缓存的元素。</p>
<ul>
<li>
<h4 id="buffertime"><code>bufferTime</code></h4>
</li>
</ul>
<p>设定源 Observable 对象已发出的值的缓冲时间。</p>
<ul>
<li>
<h4 id="buffercount"><code>bufferCount</code></h4>
</li>
</ul>
<p>缓冲源 Observable对象已发出的值，直到大小达到给定的最大 bufferSize 。</p>
<ul>
<li>
<h4 id="concatmap"><code>concatMap</code></h4>
</li>
</ul>
<p>对每个 Observable 对象发出的值，进行映射处理，并进行合并。该操作符也会先处理前一个 Observable 对象，在处理下一个 Observable 对象。</p>
<ul>
<li>
<h4 id="switchmap"><code>switchMap</code></h4>
</li>
</ul>
<p>对源 Observable 对象发出的值，做映射处理。若有新的 Observable 对象出现，会在新的 Observable 对象发出新值后，退订前一个未处理完的 Observable 对象。</p>
<ul>
<li>
<h4 id="first"><code>first</code></h4>
</li>
</ul>
<p>用于获取 Observable 对象发出的第一个元素，取完后就结束。</p>
<ul>
<li>
<h4 id="takeuntil"><code>takeUntil</code></h4>
</li>
</ul>
<p>当 takeUntil 传入的 notifier 发出值时，源 Observable 对象就会直接进入完成状态。</p>
<ul>
<li>
<h4 id="takelast"><code>takeLast</code></h4>
</li>
</ul>
<p>获取源 Observable 对象发出的，后面 count 项的值。</p>
<ul>
<li>
<h4 id="last"><code>last</code></h4>
</li>
</ul>
<p>获取源 Observable 对象发出的最后一项的值。</p>
<ul>
<li>
<h4 id="debouncetime"><code>debounceTime</code></h4>
</li>
</ul>
<p>在设定的时间跨度内，若源 Observable 对象没有再发出新值，则返回最近一次发出的值。</p>
<ul>
<li>
<h4 id="throttletime"><code>throttleTime</code></h4>
</li>
</ul>
<p>从源 Observable 对象发出第一个值开始，忽略等待时间内发出的值，等待时间过后再发出新值。与 debounceTime 不同的是，throttleTime 一开始就会发出值，在等待时间内不会发出任何值，等待时间过后又会发出新的值。</p>
<ul>
<li>
<h4 id="distinct"><code>distinct</code></h4>
</li>
</ul>
<p>过滤源 Observable 发出的值，确保不会发出重复出现的值。</p>
<ul>
<li>
<h4 id="concat"><code>concat</code></h4>
</li>
</ul>
<p>把多个 Observable 对象合并为一个 Observable 对象，Observable 对象会依次执行，即需等前一个 Observable 对象完成后，才会继续订阅下一个。</p>
<ul>
<li>
<h4 id="concatall"><code>concatAll</code></h4>
</li>
</ul>
<p>合并多个 Observable 对象，并在上一个 Observable 对象完成后订阅下一个 Observable 对象。</p>
<ul>
<li>
<h4 id="startwith"><code>startWith</code></h4>
</li>
</ul>
<p>在开始发出源 Observable 数据之前发出已设置的参数值，并返回新的 Observable 对象。</p>
<ul>
<li>
<h4 id="merge"><code>merge</code></h4>
</li>
</ul>
<p>合并 Observable 对象，并按给定的时序发出对应值。</p>
<ul>
<li>
<h4 id="mergeall"><code>mergeAll</code></h4>
</li>
</ul>
<p>将高阶 Observable 对象转换为一阶Observable 对象，并同时处理所有的 Observable 对象。</p>
<ul>
<li>
<h4 id="combinelatest-2"><code>combineLatest</code></h4>
</li>
</ul>
<p>用于合并输入的 Observable 对象，当源 Observable 对象和 other Observable 对象都发出值后，才会调用 project 函数。</p>
<ul>
<li>
<h4 id="zip"><code>zip</code></h4>
</li>
</ul>
<p>根据每个输入 Observable 对象的输出顺序，产生一个新的 Observable 对象。</p>
<ul>
<li>
<h4 id="withlatestfrom"><code>withLatestFrom</code></h4>
</li>
</ul>
<p>当源 Observable 发出新值的时候，根据 project 函数，合并 other Observable 对象此前发出的最新值。</p>
<ul>
<li>
<h4 id="switch"><code>switch</code></h4>
</li>
</ul>
<p>切换为最新的 Observable 数据源，并退订前一个 Observable 数据源。</p>
<ul>
<li>
<h4 id="delaywhen"><code>delayWhen</code></h4>
</li>
</ul>
<p>delayWhen 的作用跟 delay 操作符类似，最大的区别是 delayWhen 会影响每个元素，而且调用的时候需要设置 delayDurationSelector 函数，该函数的返回值是 Observable 对象。</p>
<ul>
<li>
<h4 id="multicast"><code>multicast</code></h4>
</li>
</ul>
<p>用于挂载 Subject 对象，并返回一个可链接 (connectable) 的 Observable 对象。</p>
<ul>
<li>
<h4 id="publish"><code>publish</code></h4>
</li>
</ul>
<p>用于挂载 Subject 对象，并返回一个可链接 (connectable) 的 Observable 对象。即 publish 操作符与 multicast(new Rx.Subject()) 是等价的。</p>
<ul>
<li>
<h4 id="share"><code>share</code></h4>
</li>
</ul>
<p>share 操作符是 publish + refCount 的简写。</p>
<ul>
<li>
<h4 id="retry"><code>retry</code></h4>
</li>
</ul>
<p>发生错误后，重试 count 次数</p>
<ul>
<li>
<h4 id="retrywhen"><code>retryWhen</code></h4>
</li>
</ul>
<p>捕获异常 Observable 对象，进行异常处理后，可重新订阅源 Observable 对象。</p>
<h2 id="简单拖拽实例">简单拖拽实例</h2>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
html, body {
  height: 100%;
  background-color: tomato;
  position: relative;
}
#drag {
  position: absolute;
  display: inline-block;
  width: 100px;
  height: 100px;
  background-color: #fff;
  cursor: all-scroll;
}
&lt;/style&gt;
&lt;div id=&quot;drag&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">const mouseDown = Rx.Observable.fromEvent(dragDOM, 'mousedown');
const mouseUp = Rx.Observable.fromEvent(body, 'mouseup');
const mouseMove = Rx.Observable.fromEvent(body, 'mousemove');
</code></pre>
<p>首先给出3个Observable，分别代表3种事件，我们希望mousedown的时候监听mousemove,然后mouseup时停止监听，于是RxJS可以这么写：</p>
<pre><code class="language-js">const source = mouseDown
.map(event =&gt; mouseMove.takeUntil(mouseUp))
</code></pre>
<p>takeUntil操作符可以在某个条件符合时，发送complete事件</p>
<pre><code class="language-js">source: -------e--------------e-----
                \              \
                  --m-m-m-m|     -m--m-m--m-m|
</code></pre>
<p>从图上可以看出，我们还需要把source扁平化，才能获取所需数据。</p>
<p>完整代码：</p>
<pre><code class="language-js">const dragDOM = document.getElementById('drag');
const body = document.body;
const mouseDown = Rx.Observable.fromEvent(dragDOM, 'mousedown');
const mouseUp = Rx.Observable.fromEvent(body, 'mouseup');
const mouseMove = Rx.Observable.fromEvent(body, 'mousemove');
mouseDown
    .flatMap(event =&gt; mouseMove.takeUntil(mouseUp))
    .map(event =&gt; ({ x: event.clientX, y: event.clientY }))
    .subscribe(pos =&gt; {
        dragDOM.style.left = pos.x + 'px';
        dragDOM.style.top = pos.y + 'px';
    })
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://cn.rx.js.org/" target="_blank" rel="nofollow">Rxjs中文文档 </a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="nofollow"> RxJS 入门指引和初步应用</a></li>
<li><a href="https://segmentfault.com/a/1190000012252368" target="_blank" rel="nofollow"> RxJS: 简单入门</a></li>
<li><a href="https://segmentfault.com/a/1190000013829356" target="_blank" rel="nofollow"> RxJS基础教程</a></li>
<li><a href="https://blog.techbridge.cc/2017/12/08/rxjs/?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com" target="_blank" rel="nofollow"> 希望是最淺顯易懂的 RxJS 教學</a></li>
<li><a href="http://xgrommx.github.io/rx-book/index.html" target="_blank" rel="nofollow"> Rxjs文档Gitbook</a></li>
<li><a href="https://segmentfault.com/a/1190000010599259" target="_blank" rel="nofollow">人人都能看懂的RXJS常用实例操作符 </a></li>
<li><a href="https://segmentfault.com/a/1190000008834251" target="_blank" rel="nofollow">RxJS Operators 详解 </a></li>
<li><a href="https://segmentfault.com/a/1190000005069851" target="_blank" rel="nofollow">RxJS 核心概念之Subject </a></li>
<li><a href="https://segmentfault.com/a/1190000008464065" target="_blank" rel="nofollow">通俗的方式理解RxJS</a></li>
<li><a href="https://segmentfault.com/a/1190000005059624" target="_blank" rel="nofollow">RxJS 核心概念Observer &amp; Subscription </a></li>
</ul>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://huxinmin.github.io/post/ionic3-kai-fa-hybird-app-chu-ti-yan/">
                                    <h3 class="post-title">
                                        Ionic3开发Hybird App初体验
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
        <a href="#!" id="tool-toc" class="hidden-xs hidden-sm">
            <i class="fa fa-map"></i>
        </a>
        <br>
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#rxjs%E7%AE%80%E4%BB%8B">Rxjs简介</a></li>
<li><a href="#reactivex%E7%AE%80%E4%BB%8B">Reactivex简介</a></li>
<li><a href="#why-rxjs">Why Rxjs</a><br>
*
<ul>
<li><a href="#%E5%A4%9A%E4%BD%99%E7%9A%84%E8%AF%B7%E6%B1%82">多余的请求</a></li>
<li><a href="#%E5%B7%B2%E6%97%A0%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BB%8D%E7%84%B6%E6%89%A7%E8%A1%8C">已无用的请求仍然执行</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95">安装方法</a><br>
*
<ul>
<li><a href="#%E9%80%9A%E8%BF%87-npm-%E5%AE%89%E8%A3%85-es6-%E7%89%88%E6%9C%AC">通过 npm 安装 ES6 版本</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-npm-%E5%AE%89%E8%A3%85-commonjs-%E7%89%88%E6%9C%AC">通过 npm 安装 CommonJS 版本</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-typescript-%E7%9A%84-commonjs-%E6%A8%A1%E5%BC%8F">使用 TypeScript 的 CommonJS 模式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-npm-%E6%89%80%E6%9C%89%E5%85%A8%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%9E%8B-cjses6amdtypescript">通过 npm 所有全模块类型 (CJS/ES6/AMD/TypeScript)</a></li>
<li><a href="#cdn">CDN</a></li>
</ul>
</li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">核心概念</a><br>
*
<ul>
<li><a href="#stream"><code>Stream</code></a></li>
<li><a href="#observable"><code>Observable</code></a></li>
<li><a href="#observer"><code>Observer</code></a></li>
<li><a href="#operator"><code>Operator</code></a></li>
<li><a href="#subject"><code>Subject</code></a></li>
<li><a href="#scheduers"><code>Scheduers</code></a></li>
<li><a href="#subscription"><code>Subscription</code></a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%BC%8F">模式</a><br>
*
<ul>
<li><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">开始使用</a><br>
*
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%BA%8F%E5%88%97">创建可观察序列</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E5%BA%8F%E5%88%97">合并序列</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E8%B7%AF%E6%8E%A8%E9%80%81%E5%BA%8F%E5%88%97">创建多路推送序列</a></li>
<li><a href="#%E6%89%81%E5%B9%B3%E5%8C%96%E6%B5%81">扁平化流</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6">常用操作符</a><br>
*
<ul>
<li><a href="#repeat"><code>repeat</code></a></li>
<li><a href="#pip"><code>pip</code></a></li>
<li><a href="#map"><code>map</code></a></li>
<li><a href="#mapto"><code>mapTo</code></a></li>
<li><a href="#pluck"><code>pluck</code></a></li>
<li><a href="#do"><code>do</code></a></li>
<li><a href="#filter"><code>filter</code></a></li>
<li><a href="#take"><code>take</code></a></li>
<li><a href="#takewhile"><code>takeWhile</code></a></li>
<li><a href="#skip"><code>skip</code></a></li>
<li><a href="#distinctuntilchanged"><code>distinctUntilChanged</code></a></li>
<li><a href="#scan"><code>scan</code></a></li>
<li><a href="#delay"><code>delay</code></a></li>
<li><a href="#toarray"><code>toArray</code></a></li>
<li><a href="#tomap"><code>toMap</code></a></li>
<li><a href="#expand"><code>expand</code></a></li>
<li><a href="#forkjoin"><code>forkJoin</code></a></li>
<li><a href="#let"><code>let</code></a></li>
<li><a href="#catch"><code>catch</code></a></li>
<li><a href="#combinelatest"><code>combineLatest</code></a></li>
<li><a href="#buffer"><code>buffer</code></a></li>
<li><a href="#buffertime"><code>bufferTime</code></a></li>
<li><a href="#buffercount"><code>bufferCount</code></a></li>
<li><a href="#concatmap"><code>concatMap</code></a></li>
<li><a href="#switchmap"><code>switchMap</code></a></li>
<li><a href="#first"><code>first</code></a></li>
<li><a href="#takeuntil"><code>takeUntil</code></a></li>
<li><a href="#takelast"><code>takeLast</code></a></li>
<li><a href="#last"><code>last</code></a></li>
<li><a href="#debouncetime"><code>debounceTime</code></a></li>
<li><a href="#throttletime"><code>throttleTime</code></a></li>
<li><a href="#distinct"><code>distinct</code></a></li>
<li><a href="#concat"><code>concat</code></a></li>
<li><a href="#concatall"><code>concatAll</code></a></li>
<li><a href="#startwith"><code>startWith</code></a></li>
<li><a href="#merge"><code>merge</code></a></li>
<li><a href="#mergeall"><code>mergeAll</code></a></li>
<li><a href="#combinelatest-2"><code>combineLatest</code></a></li>
<li><a href="#zip"><code>zip</code></a></li>
<li><a href="#withlatestfrom"><code>withLatestFrom</code></a></li>
<li><a href="#switch"><code>switch</code></a></li>
<li><a href="#delaywhen"><code>delayWhen</code></a></li>
<li><a href="#multicast"><code>multicast</code></a></li>
<li><a href="#publish"><code>publish</code></a></li>
<li><a href="#share"><code>share</code></a></li>
<li><a href="#retry"><code>retry</code></a></li>
<li><a href="#retrywhen"><code>retryWhen</code></a></li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8D%95%E6%8B%96%E6%8B%BD%E5%AE%9E%E4%BE%8B">简单拖拽实例</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>

</div>


    
<footer id="fh5co-footer">
  <p>Powered by <a href="https://huxinmin.github.io" target="_blank">胡新敏的个人博客</a></p>
</footer>


    <!-- jQuery -->
<script src="https://huxinmin.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://huxinmin.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://huxinmin.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://huxinmin.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://huxinmin.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://huxinmin.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://huxinmin.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
        var allImg = $("img");
        allImg.on("contextmenu", function () {
            return false;
        });
        allImg.on("dragstart", function () {
            return false;
        });
    
</script>




</body>
</html>
