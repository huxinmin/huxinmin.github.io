<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huxinmin.github.io</id>
    <title>胡新敏的个人博客</title>
    <updated>2020-04-20T08:11:35.364Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huxinmin.github.io"/>
    <link rel="self" href="https://huxinmin.github.io/atom.xml"/>
    <subtitle>胡新敏的个人博客</subtitle>
    <logo>https://huxinmin.github.io/images/avatar.png</logo>
    <icon>https://huxinmin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 胡新敏的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[Crontab定时任务测试]]></title>
        <id>https://huxinmin.github.io/post/crontab-ding-shi-ren-wu-ce-shi/</id>
        <link href="https://huxinmin.github.io/post/crontab-ding-shi-ren-wu-ce-shi/">
        </link>
        <updated>2020-04-20T07:46:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在Linux日常使用中，有时候我们会需要编写一些定时任务，但是定时任务是有延迟的，我们怎么知道定时任务的执行命令到底编写对了没呢？这就需要我们进行定时任务命令测试了。</p>
<h2 id="具体操作方法">具体操作方法</h2>
<p>这里为了简单，我就全部在root用户下执行操作的。</p>
<ol>
<li>假如我们使用<code>crontab -e</code>进行编写一个定时任务</li>
</ol>
<pre><code class="language-sh"> * * * * * echo &quot;test crontab&quot; &gt;&gt; /var/log/test.log
</code></pre>
<ol start="2">
<li>进入<code>/var/spool/cron</code>目录下，使用<code>ll</code>命令查看cron目录下的文件权限状况，可以看到对应的文件是没有执行权限的，需进行授权为可执行：</li>
</ol>
<pre><code class="language-sh">chmod 777 xxx(文件名)
</code></pre>
<ol start="3">
<li>重启Crontab服务</li>
</ol>
<pre><code class="language-sh">/sbin/service crond restart
</code></pre>
<ol start="4">
<li>进入<code>/var/log</code>目录下，使用<code>cat test.log</code>查看文件内容，如果内容不断增加，则代表测试成功</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react使用中的一些经验和总结]]></title>
        <id>https://huxinmin.github.io/post/react-shi-yong-zhong-de-yi-xie-jing-yan-he-zong-jie/</id>
        <link href="https://huxinmin.github.io/post/react-shi-yong-zhong-de-yi-xie-jing-yan-he-zong-jie/">
        </link>
        <updated>2020-04-20T07:44:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近一直在用React，在使用的过程中也遇到了很多的问题，然后通过思考，解决问题，也进一步加深了对React的理解，现在我就简单的总结一下自己遇到的问题和思考出的经验。</p>
<h2 id="react生命周期图">React生命周期图</h2>
<img src="data:image/jpeg;base64,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" />
<h2 id="componentwillreceiveprops"><code>componentWillReceiveProps</code></h2>
<ol>
<li>父组件只要重新渲染就会触发子组件的componentWillReceiveProps，如果属性没有变化的话，不会触发子组件的render</li>
<li>componentwillreceiveprops在初始化的时候是不会执行的</li>
<li>componentwillreceiveprops中nextprops和this.props不一样，在shouldcomponentupdate之后才会一致</li>
</ol>
<h2 id="事件写法">事件写法</h2>
<p>在React中写事件执行的方法的时候。有3种方法可以绑定this对象：</p>
<ol>
<li>使用回调函数方法</li>
</ol>
<pre><code class="language-html">handleClick() {
    console.log('this is:', this);
  }
  render() {
    return (
      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
</code></pre>
<ol start="2">
<li>使用bind方法</li>
</ol>
<pre><code class="language-html">handleClick() {
    console.log('this is:', this);
  }
  render() {
    return (
      &lt;button onClick={this.handleClick.bind(this)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
</code></pre>
<ol start="3">
<li>使用箭头函数在定义时候就绑定this对象</li>
</ol>
<pre><code class="language-html">handleClick = ()=&gt; {
    console.log('this is:', this);
  }
  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
</code></pre>
<h2 id="state"><code>state</code></h2>
<p>state写与不写在constructor中没有什么区别，如果是需要根据初始化时传入的props来计算出state的话，则需要写在constructor中</p>
<h2 id="defaultprops与proptypes"><code>defaultProps</code>与<code>propTypes</code></h2>
<p>定义组件的属性类型和默认属性<br>
在ES6里，可以统一使用static成员来实现</p>
<pre><code class="language-js">class Video extends React.Component {
    static defaultProps = {
    }
    static propTypes = {
    }
}
</code></pre>
<p>也可以写在class外面：</p>
<pre><code class="language-js">class Video extends React.Component {
}
Video.defaultProps = {
};
Video.propTypes = {
};
</code></pre>
<h2 id="getinitialstate与getdefaultprops"><code>getInitialState</code>与<code>getDefaultProps</code></h2>
<p>这两个方法是在Es5版本的React中才有，在ES6中可以直接设置state和defaultProps</p>
<h2 id="shouldcomponentupdate"><code>shouldComponentUpdate</code></h2>
<p>在shouldcomponentupdate不要对state进行操作，如果需要的话，可以在componentwillreceiveprops进行设置</p>
<h2 id="componentwillunmout"><code>componentwillunmout</code></h2>
<p>componentwillunmout会在子组件不在父组件的render的React的Dom树中出现时候执行，例如：</p>
<pre><code class="language-js">state = {e: 0}
onChange = (ev) =&gt; {
    console.log(ev.target.value)
    this.setState({
	e: ev.target.value
    })
}
render(){
    const { e } = this.state;
    return(
        &lt;article&gt;
	    &lt;input value={e} type=&quot;text&quot; onChange={this.onChange}/&gt;
		{ (e === 0) ? &lt;A /&gt; : &lt;p&gt;sss&lt;/p&gt; }
	&lt;/article&gt;
    )
}
</code></pre>
<p>只要e不为0的时候，就会触发A组件的componentwillunmout</p>
<h2 id="与第三方js插件集成">与第三方JS插件集成</h2>
<p>如果是一些传入DOM节点的插件，可以直接使用ref，但是如果是一些传入ID的，情况就有点特殊了，因为react如果复用组件的时候，生成的dom会有多个实例，所以如果集成一些需要对ID进行操作的js代码或者框架，需要将ID设置为变量，也就是需要为每个调用设置成不同的ID</p>
<h2 id="解构属性延展">解构&amp;属性延展</h2>
<p>结合使用ES6+的解构和属性延展，我们给子组件传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签：</p>
<pre><code class="language-js">render() {
        var {
            className,
            ...others
        } = this.props;
        return (
            &lt;div className={className}&gt;
                &lt;Child {...others} /&gt;
            &lt;/div&gt;
        );
}
</code></pre>
<p>下面这种写法，则是传递所有属性的同时，用覆盖新的className值：</p>
<pre><code class="language-js">&lt;div {...this.props} className=&quot;override&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值</p>
<pre><code class="language-js">&lt;div className=&quot;base&quot; {...this.props}&gt;
&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用MockJs伪造随机数据]]></title>
        <id>https://huxinmin.github.io/post/shi-yong-mockjs-wei-zao-sui-ji-shu-ju/</id>
        <link href="https://huxinmin.github.io/post/shi-yong-mockjs-wei-zao-sui-ji-shu-ju/">
        </link>
        <updated>2020-04-20T07:40:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="why-mockjs">Why MockJs?</h2>
<p>在上一篇文章我介绍了如何使用<code>json-server</code>来模拟后台，自己实现restful风格的接口，但是对于伪造数据这方面，<code>json-server</code>并不很强大，但是也可以使用faker，mockjs等来生成动态数据，虽然 mockj s可以模拟的数据不如 faker 那么多，但是由于其对中文的良好支持，并且使用了位于国内的随机图片提供商，显然是更适合国内用户使用。</p>
<p>MockJs很好的解决了以下这些问题：</p>
<ul>
<li>无法写出大量的，随机的静态模拟数据</li>
<li>无法很随意的修改静态模拟数据</li>
<li>某些逻辑复杂的代码，加入或去除模拟数据时得小心翼翼。</li>
<li>尽可能还原真实的数据</li>
<li>特殊的格式，例如IP,随机数，图片，地址</li>
<li>...</li>
</ul>
<p>虽然MockJs也可以用于拦截Ajax,但是无法定义复杂的路由和不支持跨域，所以我这篇文章只介绍使用MockJs的模拟数据的功能。</p>
<h2 id="开始-安装">开始 &amp; 安装</h2>
<pre><code class="language-js">npm install mockjs --save
</code></pre>
<pre><code class="language-js">// 使用 Mock
var Mock = require('mockjs')
var data = Mock.mock({
    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素
    'list|1-10': [{
        // 属性 id 是一个自增数，起始值为 1，每次增 1
        'id|+1': 1
    }]
})
// 输出结果
console.log(JSON.stringify(data, null, 4))
</code></pre>
<p>更多安装以及使用方式，例如Bower，RequireJS (AMD)，Sea.js (CMD)等请自行查看官方文档：<br>
<a href='https://github.com/nuysoft/Mock/wiki/Getting-Started' target="_blank" rel="nofollow">https://github.com/nuysoft/Mock/wiki/Getting-Started</a></p>
<h2 id="mockrandom生成各种随机数据"><code>Mock.Random</code>生成各种随机数据</h2>
<pre><code class="language-js">var Random = Mock.Random
Random.email()
// =&gt; &quot;n.clark@miller.io&quot;
Mock.mock('@email')
// =&gt; &quot;y.lee@lewis.org&quot;
Mock.mock( { email: '@email' } )
// =&gt; { email: &quot;v.lewis@hall.gov&quot; }
</code></pre>
<ul>
<li>
<h4 id="basic">Basic</h4>
<ul>
<li><code>Random.boolean( min?, max?, current? )</code>返回一个随机的布尔值</li>
<li><code>Random.natural( min?, max? )</code>返回一个随机的自然数（大于等于 0 的整数）</li>
<li><code>Random.integer( min?, max? )</code>返回一个随机的整数</li>
<li><code>Random.float( min?, max?, dmin?, dmax? )</code>返回一个随机的浮点数</li>
<li><code>Random.character( pool? )</code>返回一个随机字符</li>
<li><code>Random.string( pool?, min?, max? )</code>返回一个随机字符串</li>
<li><code>Random.range( start?, stop, step? )</code>返回一个整型数组</li>
</ul>
</li>
<li>
<h4 id="date">Date</h4>
<ul>
<li><code>Random.date( format? )</code>返回一个随机的日期字符串</li>
<li><code>Random.time( format? )</code>返回一个随机的时间字符串</li>
<li><code>Random.datetime( format? )</code>返回一个随机的日期和时间字符串</li>
<li><code>Random.now( unit?, format? )</code>返回当前的日期和时间字符串</li>
</ul>
</li>
<li>
<h4 id="image">Image</h4>
<ul>
<li><code>Random.image( size?, background?, foreground?, format?, text? )</code>生成一个随机的图片地址</li>
<li><code>Random.dataImage( size?, text? )</code>生成一段随机的 Base64 图片编码</li>
</ul>
</li>
<li>
<h4 id="color">Color</h4>
<ul>
<li><code>Random.color()</code>随机生成一个有吸引力的颜色，格式为 '#RRGGBB'</li>
<li><code>Random.hex()</code>随机生成一个有吸引力的颜色，格式为 '#RRGGBB'。</li>
<li><code>Random.rgb()</code>随机生成一个有吸引力的颜色，格式为 'rgb(r, g, b)'</li>
<li><code>Random.rgba()</code>随机生成一个有吸引力的颜色，格式为 'rgba(r, g, b, a)'</li>
<li><code>Random.hsl()</code>随机生成一个有吸引力的颜色，格式为 'hsl(h, s, l)'</li>
</ul>
</li>
<li>
<h4 id="text">Text</h4>
<ul>
<li><code>Random.paragraph( min?, max? )</code>随机生成一段文本</li>
<li><code>Random.cparagraph( min?, max? )</code>随机生成一段中文文本</li>
<li><code>Random.sentence( min?, max? )</code>随机生成一个句子，第一个单词的首字母大写</li>
<li><code>Random.csentence( min?, max? )</code>随机生成一段中文文本</li>
<li><code>Random.word( min?, max? )</code>随机生成一个单词</li>
<li><code>Random.cword( pool?, min?, max? )</code>随机生成一个汉字</li>
<li><code>Random.title( min?, max? )</code>随机生成一句标题，其中每个单词的首字母大写</li>
<li><code>Random.ctitle( min?, max? )</code>随机生成一句中文标题</li>
</ul>
</li>
<li>
<h4 id="name">Name</h4>
<ul>
<li><code>Random.first()</code> 随机生成一个常见的英文名</li>
<li><code>Random.last()</code>随机生成一个常见的英文姓</li>
<li><code>Random.name( middle? )</code>随机生成一个常见的英文姓名</li>
<li><code>Random.cfirst()</code>随机生成一个常见的中文名</li>
<li><code>Random.clast()</code>随机生成一个常见的中文姓</li>
<li><code>Random.cname()</code>随机生成一个常见的中文姓名</li>
</ul>
</li>
<li>
<h4 id="web">Web</h4>
<ul>
<li><code>Random.url( protocol?, host? )</code>随机生成一个 URL</li>
<li><code>Random.protocol()</code>随机生成一个 URL 协议</li>
<li><code>Random.domain()</code>随机生成一个域名</li>
<li><code>Random.tld()</code>随机生成一个顶级域名（Top Level Domain）</li>
<li><code>Random.email( domain? )</code>随机生成一个邮件地址</li>
<li><code>Random.ip()</code>随机生成一个 IP 地址</li>
</ul>
</li>
<li>
<h4 id="address">Address</h4>
<ul>
<li><code>Random.region()</code>随机生成一个（中国）大区</li>
<li><code>Random.province()</code>随机生成一个（中国）省（或直辖市、自治区、特别行政区）</li>
<li><code>Random.city( prefix? )</code>随机生成一个（中国）市</li>
<li><code>Random.county( prefix? )</code>随机生成一个（中国）县</li>
<li><code>Random.zip()</code>随机生成一个邮政编码（六位数字）</li>
</ul>
</li>
<li>
<h4 id="helper">Helper</h4>
<ul>
<li><code>Random.capitalize( word )</code>把字符串的第一个字母转换为大写</li>
<li><code>Random.upper( str )</code>把字符串转换为大写</li>
<li><code>Random.lower( str )</code>把字符串转换为小写</li>
<li><code>Random.pick( arr )</code>从数组中随机选取一个元素，并返回</li>
<li><code>Random.shuffle( arr )</code>打乱数组中元素的顺序，并返回</li>
</ul>
</li>
<li>
<h4 id="miscellaneous">Miscellaneous</h4>
<ul>
<li><code>Random.guid()</code>随机生成一个 GUID</li>
<li><code>Random.id()</code>随机生成一个 18 位身份证</li>
<li><code>Random.increment( step? )</code>生成一个全局的自增整数</li>
</ul>
</li>
</ul>
<h2 id="randomextend自定义数据拓展"><code>Random.extend</code>自定义数据拓展</h2>
<pre><code class="language-js">var Random = Mock.Random
Random.extend({
    constellation: function(date) {
        var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座']
        return this.pick(constellations)
    }
})
Random.constellation()  // =&gt; &quot;水瓶座&quot;
Mock.mock('@CONSTELLATION')  // =&gt; &quot;天蝎座&quot;
Mock.mock({
    constellation: '@CONSTELLATION'
})
// =&gt; { constellation: &quot;射手座&quot; }
</code></pre>
<h2 id="数据生成规范">数据生成规范</h2>
<ul>
<li>
<h4 id="数据模板定义规范data-template-definitiondtd">数据模板定义规范（Data Template Definition，DTD）</h4>
</li>
</ul>
<pre><code class="language-js">// 属性名   name
// 生成规则 rule
// 属性值   value
'name|rule': value
</code></pre>
<p>注意：</p>
<ul>
<li>属性名 和 生成规则 之间用竖线 <code>|</code>分隔。</li>
<li>生成规则 是可选的。</li>
<li>生成规则 有 7 种格式：
<ul>
<li><code>'name|min-max': value</code></li>
<li><code>'name|count': value</code></li>
<li><code>'name|min-max.dmin-dmax': value</code></li>
<li><code>'name|min-max.dcount': value</code></li>
<li><code>'name|count.dmin-dmax': value</code></li>
<li><code>'name|count.dcount': value</code></li>
<li><code>'name|+step': value</code></li>
</ul>
</li>
<li>生成规则 的 含义 需要依赖 属性值的类型 才能确定。</li>
<li>属性值 中可以含有 <code>@</code>占位符。</li>
<li>属性值 还指定了最终值的初始值和类型。</li>
<li>
<h4 id="数据占位符定义规范data-placeholder-definitiondpd">数据占位符定义规范（Data Placeholder Definition，DPD）</h4>
</li>
</ul>
<p>只能使用在<code>Mock.mock</code>中的数据模板中</p>
<pre><code class="language-js">@占位符
@占位符(参数 [, 参数])
</code></pre>
<p>注意：</p>
<ul>
<li>用 <code>@</code>来标识其后的字符串是 占位符</li>
<li>占位符 引用的是<code>Mock.Random</code> 中的方法</li>
<li>通过 <code>Mock.Random.extend()</code> 来扩展自定义占位符</li>
<li>占位符 也可以引用 数据模板 中的属性</li>
<li>占位符 会优先引用 数据模板 中的属性</li>
<li>占位符 支持 相对路径 和 绝对路径</li>
</ul>
<h2 id="实例">实例</h2>
<pre><code class="language-js">Mock.mock({
    name: {
        first: '@FIRST',
        middle: '@FIRST',
        last: '@LAST',
        full: '@first @middle @last'
    }
})
// =&gt;
{
    &quot;name&quot;: {
        &quot;first&quot;: &quot;Charles&quot;,
        &quot;middle&quot;: &quot;Brenda&quot;,
        &quot;last&quot;: &quot;Lopez&quot;,
        &quot;full&quot;: &quot;Charles Brenda Lopez&quot;
    }
}
Mock.mock({
    'regexp1': /[a-z][A-Z][0-9]/,
    'regexp2': /\w\W\s\S\d\D/,
    'regexp3': /\d{5,10}/
})
// =&gt;
{
    &quot;regexp1&quot;: &quot;pJ7&quot;,
    &quot;regexp2&quot;: &quot;F)\fp1G&quot;,
    &quot;regexp3&quot;: &quot;561659409&quot;
}
{
        
         title: Random.cword(8,20),
         desc: content.substr(0,40),
         tag: Random.cword(2,6),
         views: Random.integer(100,5000),
         images: images.slice(0,Random.integer(1,3))
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不再依赖后台，使用json-server模拟restful接口]]></title>
        <id>https://huxinmin.github.io/post/bu-zai-yi-lai-hou-tai-shi-yong-json-server-mo-ni-restful-jie-kou/</id>
        <link href="https://huxinmin.github.io/post/bu-zai-yi-lai-hou-tai-shi-yong-json-server-mo-ni-restful-jie-kou/">
        </link>
        <updated>2020-04-20T07:40:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="why-json-server">Why json-server?</h2>
<p>在所有的项目开发中，前端开发都需要后台提供接口和数据，才能进行下一步的开发，但是后台开发多半是滞后于前端开发的，那么我们怎么才能自己临时地来模拟数据，并行开发呢？答案就是MOCK数据，对比过多种mock工具后，最终选择了使用 json server ，因为它足够简单，且足够强大，支持CORS和JSONP跨域请求，支持GET, POST, PUT, PATCH 和 DELETE 方法，更提供了一系列的查询方法，如limit，order等。</p>
<h2 id="安装使用">安装使用</h2>
<pre><code class="language-js">npm install -g json-server
</code></pre>
<p>然后在根目录下面新建一个文件<code>db.json</code>:</p>
<pre><code class="language-js">{
  &quot;posts&quot;: [
    { &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }
  ],
  &quot;comments&quot;: [
    { &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 }
  ],
  &quot;profile&quot;: { &quot;name&quot;: &quot;typicode&quot; }
}
</code></pre>
<p>然后开始即可：</p>
<pre><code class="language-js">json-server --watch db.json
</code></pre>
<p>在浏览器里输入<code>http://localhost:3000/posts/1</code>你会看到下面的结果：</p>
<pre><code class="language-js">{ &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }
</code></pre>
<p>下面四点需要注意：</p>
<ul>
<li>POST, PUT, PATCH ,DELETE等请求提交时，会使用lowdb自动改变<code>db.json</code>并保存</li>
<li>所有提交的JSON数据都必须闭合在花括号里面</li>
<li>ID无法修改，只能使用POST新增</li>
<li>POST, PUT , PATCH等请求如果使用JSON数据提交时必需包含<code>Content-Type: application/json</code>，否则虽然会返回200但是数据不会改变</li>
</ul>
<p>所有的使用选项如下：</p>
<pre><code class="language-js">json-server [options] &lt;source&gt;

Options:
  --config, -c       配置文件路径           [default: &quot;json-server.json&quot;]
  --port, -p         端口号                 [default: 3000]
  --host, -H         主机地址               [default: &quot;localhost&quot;]
  --watch, -w        是否监听文件           [boolean]
  --routes, -r       路由文件路径
  --middlewares, -m  中间件文件路径         [array]
  --static, -s       静态文件目录
  --read-only, --ro  只允许GET请求          [boolean]
  --no-cors, --nc    禁止跨域               [boolean]
  --no-gzip, --ng    禁止GZIP压缩           [boolean]
  --snapshots, -S    设置快照目录            [default: &quot;.&quot;]
  --delay, -d        响应延迟(ms)
  --id, -i           设置数据库ID属性 (e.g. _id)   [default: &quot;id&quot;]
  --foreignKeySuffix, --fks  设置前缀, (e.g. _id as in post_id)
                                                   [default: &quot;Id&quot;]
  --quiet, -q        不输出日志信息                 [boolean]
  --help, -h         Show help                    [boolean]
  --version, -v      Show version number          [boolean]

Examples:
  json-server db.json
  json-server file.js
  json-server http://example.com/db.json

https://github.com/typicode/json-server
</code></pre>
<h2 id="默认路由">默认路由</h2>
<ul>
<li>
<h4 id="复数路由针对数组数据">复数路由，针对数组数据：</h4>
</li>
</ul>
<pre><code class="language-js">GET    /posts
GET    /posts/1
POST   /posts
PUT    /posts/1
PATCH  /posts/1
DELETE /posts/1
</code></pre>
<ul>
<li>
<h4 id="单数路由针对对象数据">单数路由，针对对象数据：</h4>
</li>
</ul>
<pre><code class="language-js">GET    /profile
POST   /profile
PUT    /profile
PATCH  /profile
</code></pre>
<ul>
<li>
<h4 id="过滤器你可以使用进行深层次的属性匹配">过滤器，你可以使用<code>.</code>进行深层次的属性匹配：</h4>
</li>
</ul>
<pre><code class="language-js">GET /posts?title=json-server&amp;author=typicode
GET /posts?id=1&amp;id=2
GET /comments?author.name=typicode
</code></pre>
<ul>
<li>
<h4 id="分页默认是返回10条数据">分页，默认是返回10条数据</h4>
</li>
</ul>
<pre><code class="language-js">GET /posts?_page=7
GET /posts?_page=1&amp;_limit=2
</code></pre>
<p>返回除了获取的数据，在头部还会有一个<code>Link</code>头，包括了<code>first</code>, <code>prev</code>, <code>next</code>,<code>last</code> 链接:</p>
<pre><code class="language-js">&lt;http://localhost:3000/posts?_page=1&amp;_limit=1&gt;; rel=&quot;first&quot;, &lt;http://localhost:3000/posts?_page=1&amp;_limit=1&gt;; rel=&quot;prev&quot;, &lt;http://localhost:3000/posts?_page=3&amp;_limit=1&gt;; rel=&quot;next&quot;, &lt;http://localhost:3000/posts?_page=5&amp;_limit=1&gt;; rel=&quot;last&quot;
</code></pre>
<ul>
<li>
<h4 id="排序">排序</h4>
</li>
</ul>
<pre><code class="language-js">GET /posts?_sort=views&amp;_order=asc
GET /posts/1/comments?_sort=votes&amp;_order=asc
GET /posts?_sort=user,views&amp;_order=desc,asc
</code></pre>
<ul>
<li>
<h4 id="切片">切片</h4>
</li>
</ul>
<pre><code class="language-js">GET /posts?_start=20&amp;_end=30
GET /posts/1/comments?_start=20&amp;_end=30
GET /posts/1/comments?_start=20&amp;_limit=10
</code></pre>
<p>除了返回数据外，在返回的消息头部，还有一个<code>X-Total-Count</code>字段，代表了所有的数据的总量</p>
<ul>
<li>
<h4 id="操作符">操作符</h4>
</li>
</ul>
<pre><code class="language-js">_gte: 大于等于
_lte: 小于等于
_ne : 不等于
_like : 正则匹配
GET /posts?views_gte=10&amp;views_lte=20
GET /posts?id_ne=1
GET /posts?title_like=server
</code></pre>
<ul>
<li>
<h4 id="全文查询">全文查询</h4>
</li>
</ul>
<p>使用<code>q</code>：</p>
<pre><code class="language-js">GET /posts?q=internet
</code></pre>
<ul>
<li>
<h4 id="关系">关系</h4>
</li>
</ul>
<p>嵌入子属性使用<code>_embed</code>，嵌入父属性使用<code>_expand</code>:</p>
<pre><code class="language-js">GET /posts?_embed=comments
GET /posts/1?_embed=comments
GET /comments?_expand=post
GET /comments/1?_expand=post
</code></pre>
<p>获取或者创建嵌套属性：</p>
<pre><code class="language-js">GET  /posts/1/comments
POST /posts/1/comments
</code></pre>
<ul>
<li>
<h4 id="获取所有数据">获取所有数据</h4>
</li>
</ul>
<pre><code class="language-js">GET /db
</code></pre>
<ul>
<li>
<h4 id="首页">首页</h4>
</li>
</ul>
<pre><code class="language-js">GET /
</code></pre>
<h2 id="其他">其他</h2>
<ul>
<li>
<h4 id="静态文件服务器">静态文件服务器</h4>
</li>
</ul>
<p>只需要在根目录创建一个<code>public</code>的目录即可，或者使用<code>--static</code>手动设置别的目录</p>
<ul>
<li>
<h4 id="使用远程数据">使用远程数据</h4>
</li>
</ul>
<pre><code class="language-js">$ json-server http://example.com/file.json
$ json-server http://jsonplaceholder.typicode.com/db
</code></pre>
<ul>
<li>
<h4 id="使用动态生成的数据">使用动态生成的数据</h4>
</li>
</ul>
<pre><code class="language-js">// index.js
module.exports = () =&gt; {
  const data = { users: [] }
  // Create 1000 users
  for (let i = 0; i &lt; 1000; i++) {
    data.users.push({ id: i, name: `user${i}` })
  }
  return data
}
</code></pre>
<pre><code class="language-js">$ json-server index.js
</code></pre>
<ul>
<li>
<h4 id="自定义路由路由改写以及映射">自定义路由（路由改写以及映射）</h4>
</li>
</ul>
<p>新建一个<code>routes.json</code>文件：</p>
<pre><code class="language-js">{
  &quot;/api/*&quot;: &quot;/$1&quot;,
  &quot;/:resource/:id/show&quot;: &quot;/:resource/:id&quot;,
  &quot;/posts/:category&quot;: &quot;/posts?category=:category&quot;,
  &quot;/articles\\?id=:id&quot;: &quot;/posts/:id&quot;
}
</code></pre>
<pre><code class="language-js">json-server db.json --routes routes.json
</code></pre>
<p>现在这些路由就会被映射成：</p>
<pre><code class="language-js">/api/posts # → /posts
/api/posts/1  # → /posts/1
/posts/1/show # → /posts/1
/posts/javascript # → /posts?category=javascript
/articles?id=1 # → /posts/1
</code></pre>
<p><code>！！！注意，重要的事情说三遍：</code><br>
<code>！！！注意，重要的事情说三遍：</code><br>
<code>！！！注意，重要的事情说三遍：</code><br>
上一个被映射的URL会重新匹配下面的映射规则，因此很有可能被再次映射：例如：</p>
<pre><code class="language-js">/api/posts/1  # → /posts/1
</code></pre>
<p>会继续匹配下面的<code>/posts/javascript</code>因而最终变成了<code>/posts?category=1</code>，和顺序有关，只会继续往下匹配改写，不会往上匹配，而且匹配后显示的URL并不改变，因此需要非常注意谨慎。</p>
<ul>
<li>
<h4 id="使用中间件">使用中间件</h4>
</li>
</ul>
<pre><code class="language-js">// hello.js
module.exports = (req, res, next) =&gt; {
  res.header('X-Hello', 'World')
  next()
}
</code></pre>
<pre><code class="language-js">json-server db.json --middlewares ./hello.js
json-server db.json --middlewares ./first.js ./second.js
</code></pre>
<ul>
<li>
<h4 id="使用配置文件">使用配置文件</h4>
</li>
</ul>
<p>新建一个<code>json-server.json</code>或者使用<code>--config, -c</code>来指定：</p>
<pre><code class="language-js">{
  &quot;port&quot;: 3000,
  &quot;host&quot;: 'http://127.0.0.1'
  ...
}
</code></pre>
<h2 id="模块使用">模块使用</h2>
<ul>
<li>
<h4 id="安装使用-2">安装使用</h4>
</li>
</ul>
<p>你也可以把<code>json-server</code>当做一个模块和其他的express中间件一起使用：</p>
<pre><code class="language-js">$ npm install json-server --save-dev
</code></pre>
<pre><code class="language-js">// server.js
const jsonServer = require('json-server')
const server = jsonServer.create()
const router = jsonServer.router('db.json')
const middlewares = jsonServer.defaults()
server.use(middlewares)
server.use(router)
server.listen(3000, () =&gt; {
  console.log('JSON Server is running')
})
</code></pre>
<pre><code class="language-js">$ node server.js
</code></pre>
<p>注意：<code>jsonServer.router()</code>也可以在现成的express项目中进行使用</p>
<ul>
<li>
<h4 id="自定义json-server之外的路由">自定义json-server之外的路由</h4>
</li>
</ul>
<pre><code class="language-js">// Add custom routes before JSON Server router
server.get('/echo', (req, res) =&gt; {
  res.jsonp(req.query)
})
server.use((req, res, next) =&gt; {
  if (req.method === 'POST') {
    req.body.createdAt = Date.now()
  }
  // Continue to JSON Server router
  next()
})
</code></pre>
<ul>
<li>
<h4 id="访问控制">访问控制</h4>
</li>
</ul>
<pre><code class="language-js">server.use((req, res, next) =&gt; {
 if (isAuthorized(req)) { // add your authorization logic here
   next() // continue to JSON Server router
 } else {
   res.sendStatus(401)
 }
})
</code></pre>
<ul>
<li>
<h4 id="自定义输出">自定义输出</h4>
</li>
</ul>
<p>其实所有的要返回的匹配的数据都在<code>res.locals.data</code>里，这样我们就可以自定义输出了：</p>
<pre><code class="language-js">router.render = (req, res) =&gt; {
  res.jsonp({
    body: res.locals.data
  })
}
router.render = (req, res) =&gt; {
  res.status(500).jsonp({
    error: &quot;error message here&quot;
  })
}
</code></pre>
<ul>
<li>
<h4 id="自定义路由路由改写以及映射-2">自定义路由（路由改写以及映射）</h4>
</li>
</ul>
<pre><code class="language-js">const router1 = jsonServer.router('db1.json')
const router2 = jsonServer.router('db2.json')
server.use(jsonServer.rewriter({
  '/api/*': '/$1',
  '/blog/:resource/:id/show': '/:resource/:id'
}))
server.use('/post', jsonServer.rewriter({
  '/api/*': '/$1',
  '/blog/:resource/:id/show': '/:resource/:id'
}))
server.use('/post1',router1)
server.use('/post2',router2)
</code></pre>
<p>注意，路由改写应该写在<code>server.use(router)</code>之前，否则无效</p>
<h2 id="api">API</h2>
<ul>
<li><code>jsonServer.create()</code>返回一个express服务器</li>
<li><code>jsonServer.defaults([options])</code>返回使用的中间件
<ul>
<li>static path to static files</li>
<li>logger enable logger middleware (default: true)</li>
<li>bodyParser enable body-parser middleware (default: true)</li>
<li>noCors disable CORS (default: false)</li>
<li>readOnly accept only GET requests (default: false)</li>
</ul>
</li>
<li><code>jsonServer.router([path|object])</code>返回router</li>
</ul>
<h2 id="配合mockjs使用">配合Mockjs使用</h2>
<pre><code class="language-js">// data
const Mock  = require('mockjs')
const Random = Mock.Random
module.exports = () =&gt; {
  const data = {products: []}
  data.products.push({
    name: Random.name()
  })
  return data
}
</code></pre>
<pre><code class="language-js">// server.js
const jsonServer = require('json-server')
const server = jsonServer.create()
const middlewares = jsonServer.defaults()
const products_db = require('./data/products.js')
const products_router = jsonServer.router(products_db())
server.use(middlewares)
server.use(jsonServer.bodyParser)
server.use(products_router)
server.listen(9000, () =&gt; {
  console.log('JSON Server is running')
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js中基本类型和引用类型]]></title>
        <id>https://huxinmin.github.io/post/js-zhong-ji-ben-lei-xing-he-yin-yong-lei-xing/</id>
        <link href="https://huxinmin.github.io/post/js-zhong-ji-ben-lei-xing-he-yin-yong-lei-xing/">
        </link>
        <updated>2020-04-20T07:38:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2>
<ul>
<li>
<h4 id="基本类型">基本类型</h4>
</li>
</ul>
<p>基本类型是变量中的实际的值，指的是简单的数据段，基本数据类型有这五种:<code>Undefined</code>、<code>Null</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code></p>
<ul>
<li>
<h4 id="引用类型">引用类型</h4>
</li>
</ul>
<p>引用类型值指那些可能为多个值构成的对象。引用类型有这几种：<code>object</code>、<code>Array</code>、<code>RegExp</code>、<code>Date</code>、<code>Function</code>、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)</p>
<h2 id="区别">区别</h2>
<ul>
<li>
<h4 id="引用类型值可添加属性和方法而基本类型值则不可以">引用类型值可添加属性和方法，而基本类型值则不可以</h4>
</li>
<li>
<h4 id="在赋值语句中基本类型是直接把值传递给另外一个变量稍后改变该变量的值不会影响另外一个变量的值但是引用类型是把需要赋值对象的指针指向该变量的地址由于它们指向同一个对象修改会互相影响">在赋值语句中，基本类型是直接把值传递给另外一个变量，稍后改变该变量的值不会影响另外一个变量的值，但是引用类型是把需要赋值对象的指针指向该变量的地址，由于它们指向同一个对象，修改会互相影响</h4>
</li>
<li>
<h4 id="传递参数时基本类型传参内部不会改变外部传入对象的值引用类型则会改变因为指向同一个对象">传递参数时，基本类型传参内部不会改变外部传入对象的值，引用类型则会改变，因为指向同一个对象</h4>
</li>
<li>
<h4 id="类型检测时typeof能确定变量是字符串-数值-布尔值还是undefined但是无法确定对象类型instanceof才能判断某个对象类型">类型检测时，<code>typeof</code>能确定变量是字符串、数值、布尔值还是<code>undefined</code>，但是无法确定对象类型，<code>instanceof</code>才能判断某个对象类型。</h4>
</li>
<li>
<h4 id="存放位置基本类型的数据是存放在栈内存中的而引用类型的数据是存放在堆内存中的基本类型的复制就是在栈内存中开辟出了一个新的存储区域用来存储新的变量这个变量有它自己的值只不过和前面的值一样所以如果其中一个的值改变则不会影响到另一个">存放位置，基本类型的数据是存放在栈内存中的，而引用类型的数据是存放在堆内存中的，基本类型的复制就是在栈内存中开辟出了一个新的存储区域用来存储新的变量，这个变量有它自己的值，只不过和前面的值一样，所以如果其中一个的值改变，则不会影响到另一个</h4>
</li>
<li>
<h4 id="比较基本类型的比较是值的比较引用类型的比较是引用的比较">比较，基本类型的比较是值的比较，引用类型的比较是引用的比较</h4>
</li>
</ul>
<pre><code class="language-js">var a ={}
var b ={}
a===b //false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Moment.js 详细教程2]]></title>
        <id>https://huxinmin.github.io/post/momentjs-xiang-xi-jiao-cheng-2/</id>
        <link href="https://huxinmin.github.io/post/momentjs-xiang-xi-jiao-cheng-2/">
        </link>
        <updated>2020-04-20T07:37:50.000Z</updated>
        <content type="html"><![CDATA[<p>本文是接着上一篇文章写得，地址为：<a href="https://www.huxinmin.com/home/5ad755c6117a030debfa10e0.html" target="_blank">Moment.js 详细教程1</a></p>
<h2 id="国际化">国际化</h2>
<p>Moment.js非常键全的支持日期时间的国际化。你可以载入多个区域的时间，并且可以轻松的在它们之间切换。你也可以将某个详细区域的时间，设置为全局时间。</p>
<ol>
<li>取得或设置全局语言，传入值表示设置，不传入值表示获取</li>
</ol>
<pre><code class="language-js">// From 2.8.1 之后
moment.locale(String);
moment.locale(String[]);
moment.locale(String, Object);
// 2.8.1之前
moment.lang(String);
moment.lang(String[]);
moment.lang(String, Object);
</code></pre>
<pre><code class="language-js">moment.locale('fr', {
    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourd’hui à] LT',
        nextDay : '[Demain à] LT',
        nextWeek : 'dddd [à] LT',
        lastDay : '[Hier à] LT',
        lastWeek : 'dddd [dernier à] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse : /\d{1,2}(er|e)/,
    ordinal : function (number) {
        return number + (number === 1 ? 'er' : 'e');
    },
    meridiemParse : /PD|MD/,
    isPM : function (input) {
        return input.charAt(0) === 'M';
    },
    // In case the meridiem units are not separated around 12, then implement
    // this function (look at locale/id.js for an example).
    // meridiemHour : function (hour, meridiem) {
    //     return /* 0-23 hour, given meridiem token and hour 1-12 */ ;
    // },
    meridiem : function (hours, minutes, isLower) {
        return hours &lt; 12 ? 'PD' : 'MD';
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});
</code></pre>
<ol start="2">
<li>更改或获取局部语言，传参表示更改，不传参数表示获取</li>
</ol>
<pre><code class="language-js">// 2.8.1 版本之前
moment().locale(String);
// 2.8.1 版本之后
moment().lang(String);
</code></pre>
<ol start="3">
<li><code>Node.js</code>中加载语言<br>
如果<code>moment-root/locale/</code>中已经存在语言文件，在首次调用moment.locale方法时，传入指定语言的key即可加载。</li>
</ol>
<pre><code class="language-js">moment.locale(String);
</code></pre>
<ol start="4">
<li>浏览器中加载语言</li>
</ol>
<pre><code class="language-js">&lt;script src=&quot;moment.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;locale/fr.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;locale/pt.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  moment.locale('fr');  // Set the default/global locale
  // ...
&lt;/script&gt;
</code></pre>
<ol start="5">
<li>列出当前使用语言的月份和星期</li>
</ol>
<pre><code class="language-js">moment.months()
//[&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;]
moment.monthsShort()
//[&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]
moment.weekdays()
//[&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;]
moment.weekdaysShort()
//[&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;]
moment.weekdaysMin()
//[&quot;Su&quot;, &quot;Mo&quot;, &quot;Tu&quot;, &quot;We&quot;, &quot;Th&quot;, &quot;Fr&quot;, &quot;Sa&quot;]
moment.weekdays(true, 2)
//&quot;Tuesday&quot;
moment.monthsShort('-MMM-');
//[&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]
moment.monthsShort('-MMM-', 3);
//&quot;Apr&quot;
</code></pre>
<ol start="6">
<li>获取语言数据<br>
通过<code>moment.localeData(key)</code>函数，你可以查看当前载入语言的各种属性。</li>
</ol>
<pre><code class="language-js">var currentLocaleData = moment.localeData();
var frLocaleData = moment.localeData('fr');
</code></pre>
<pre><code class="language-js">localeData.months(aMoment);  // 指定时间月份的全名
localeData.monthsShort(aMoment);  // 指定时间月份的缩写
localeData.monthsParse(longOrShortMonthString);  // 返回输入月份的序号 (0 〜 11) 
localeData.weekdays(aMoment);  // 指定时间星期的全名
localeData.weekdaysShort(aMoment);  // 指定时间星期的缩写
localeData.weekdaysMin(aMoment);  // 指定时间星期的缩写
localeData.weekdaysParse(minShortOrLongWeekdayString);  // 返回输入星期的序号 (0 〜 6) 
localeData.longDateFormat(dateFormat);  // 返回指定日期时间缩写格式的全写，如：LT, L, LL等
localeData.isPM(amPmString);  // 是否 AM、PM 字符串
localeData.meridiem(hours, minutes, isLower);  // 返回指定日期大小写形式的 am/pm 字符串
localeData.calendar(key, aMoment);  // 返回日历格式。Key可以是：'sameDay', 'nextDay', 'lastDay', 'nextWeek', 'prevWeek', 'sameElse'
localeData.relativeTime(number, withoutSuffix, key, isFuture);  // 返回一个相对时间的字符串。Key可以是：'s', 'm', 'mm', 'h', 'hh', 'd', 'dd', 'M', 'MM', 'y', 'yy'
localeData.pastFuture(diff, relTime);  // 转换实际时间 relTime 到过去或未来的 diff的值
localeData.ordinal(number);  // 转换数字到序数 1 -&gt; 1st
localeData.preparse(str);  // 调用转换之前的字符串
localeData.postformat(str);  // 调用格式之后的字符串
localeData.week(aMoment);  // 返回指定时间年中的周数
localeData.invalidDate();  // 返回 'Invalid date'
localeData.firstDayOfWeek();  // 0-6 (周日到周六)
localeData.firstDayOfYear();  // 0-15
</code></pre>
<h2 id="自定义">自定义</h2>
<p><code>Moment.js</code>可以非常简单的进行自定义。一般情况下，你需要创建一个您要进行自定义的语言的配置。</p>
<pre><code class="language-js">moment.locale('en-my-settings', {
    // 配置.
});
</code></pre>
<p>当然，你也可对已经载入的现有语言进行修改，第二个参数中传入null表示删除之前定义的语言</p>
<pre><code class="language-js">moment.locale('fr'); // 'fr'
moment.locale('en'); // 'en'
moment.locale('fr', null);
moment.locale('fr'); // 'en'
</code></pre>
<p>截止到2.12.0 版本你可以使用继承父类属性：</p>
<pre><code class="language-js">moment.defineLocale('en-foo', {
  parentLocale: 'en',
  /* */
});
</code></pre>
<p>截止到2.16.0 你定义子类语言时使用的父类可以没有定义或加载：</p>
<pre><code class="language-js">moment.defineLocale('fakeLocale', {parentLocale:'xyz'})
</code></pre>
<p>截止到2.12.0 ，你可以更新属性：</p>
<pre><code class="language-js">moment.updateLocale('en', {
  /**/
});
</code></pre>
<p>取消更新使用：</p>
<pre><code class="language-js">moment.updateLocale('en', null);
</code></pre>
<p>有如下属性可以进行定义或修改：</p>
<ul>
<li>months 月份名</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    months : [
        &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
        &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;
    ]
});
moment.updateLocale('en', {
    months : function (momentToFormat, format) {
        // momentToFormat是要格式化的时间
        // format是格式化字符串
        if (/^MMMM/.test(format)) { // 如果格式化格式为 'MMMM'
            return nominative[momentToFormat.month()];
        } else {
            return subjective[momentToFormat.month()];
        }
    }
});
</code></pre>
<ul>
<li>monthsShort 月份名缩写</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    monthsShort : [
        &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,
        &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;
    ]
});
moment.updateLocale('en', {
    monthsShort : function (momentToFormat, format) {
        if (/^MMMM/.test(format)) {
            return nominative[momentToFormat.month()];
        } else {
            return subjective[momentToFormat.month()];
        }
    }
});
</code></pre>
<ul>
<li>weekdays星期名</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    weekdays : [
        &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;
    ]
});
moment.updateLocale('en', {
    weekdays : function (momentToFormat, format) {
        return weekdays[momentToFormat.day()];
    }
});
</code></pre>
<ul>
<li>weekdaysShort星期名 (缩写)</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    weekdaysShort : [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;]
});
moment.updateLocale('en', {
    weekdaysShort : function (momentToFormat, format) {
        return weekdaysShort[momentToFormat.day()];
    }
});
</code></pre>
<ul>
<li>weekdaysMin星期名 (极简缩写)</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    weekdaysMin : [&quot;Su&quot;, &quot;Mo&quot;, &quot;Tu&quot;, &quot;We&quot;, &quot;Th&quot;, &quot;Fr&quot;, &quot;Sa&quot;]
});
moment.updateLocale('en', {
    weekdaysMin : function (momentToFormat, format) {
        return weekdaysMin[momentToFormat.day()];
    }
});
</code></pre>
<ul>
<li>longDateFormat长日期格式</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    longDateFormat : {
        LT: &quot;h:mm A&quot;,
        LTS: &quot;h:mm:ss A&quot;,
        L: &quot;MM/DD/YYYY&quot;,
        l: &quot;M/D/YYYY&quot;,
        LL: &quot;MMMM Do YYYY&quot;,
        ll: &quot;MMM D YYYY&quot;,
        LLL: &quot;MMMM Do YYYY LT&quot;,
        lll: &quot;MMM D YYYY LT&quot;,
        LLLL: &quot;dddd, MMMM Do YYYY LT&quot;,
        llll: &quot;ddd, MMM D YYYY LT&quot;
    }
});
</code></pre>
<ul>
<li>relativeTime相对时间</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    relativeTime : {
        future: &quot;in %s&quot;,
        past:   &quot;%s ago&quot;,
        s  : 'a few seconds',
        ss : '%d seconds',
        m:  &quot;a minute&quot;,
        mm: &quot;%d minutes&quot;,
        h:  &quot;an hour&quot;,
        hh: &quot;%d hours&quot;,
        d:  &quot;a day&quot;,
        dd: &quot;%d days&quot;,
        M:  &quot;a month&quot;,
        MM: &quot;%d months&quot;,
        y:  &quot;a year&quot;,
        yy: &quot;%d years&quot;
    }
});
</code></pre>
<ul>
<li>meridiem上午下午</li>
</ul>
<pre><code class="language-js">moment.updateLocale('zh-cn', {
    meridiem : function (hour, minute, isLowercase) {
        if (hour &lt; 9) {
            return &quot;早上&quot;;
        } else if (hour &lt; 11 &amp;&amp; minute &lt; 30) {
            return &quot;上午&quot;;
        } else if (hour &lt; 13 &amp;&amp; minute &lt; 30) {
            return &quot;中午&quot;;
        } else if (hour &lt; 18) {
            return &quot;下午&quot;;
        } else {
            return &quot;晚上&quot;;
        }
    }
});
</code></pre>
<ul>
<li>meridiemParse上午下午解析</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    isPM : function (input) {
        return ((input + '').toLowerCase()[0] === 'p');
    }
});
</code></pre>
<ul>
<li>calendar日历</li>
</ul>
<pre><code class="language-js">moment.locale('en', {
    calendar : {
        lastDay : '[Yesterday at] LT',
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        lastWeek : '[last] dddd [at] LT',
        nextWeek : 'dddd [at] LT',
        sameElse : 'L'
    }
});
</code></pre>
<ul>
<li>calendarFormat 日历格式化</li>
</ul>
<pre><code class="language-js">moment.calendarFormat = function (myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    var nextMonth = now.clone().add(1, 'month');

    var retVal =  diff &lt; -6 ? 'sameElse' :
        diff &lt; -1 ? 'lastWeek' :
        diff &lt; 0 ? 'lastDay' :
        diff &lt; 1 ? 'sameDay' :
        diff &lt; 2 ? 'nextDay' :
        diff &lt; 7 ? 'nextWeek' :
        // introduce thisMonth and nextMonth
        (myMoment.month() === now.month() &amp;&amp; myMoment.year() === now.year()) ? 'thisMonth' :
        (nextMonth.month() === myMoment.month() &amp;&amp; nextMonth.year() === myMoment.year()) ? 'nextMonth' : 'sameElse';
    return retVal;
};
</code></pre>
<ul>
<li>ordinal比较</li>
</ul>
<pre><code class="language-js">moment.updateLocale('en', {
    ordinal : function (number, token) {
        var b = number % 10;
        var output = (~~ (number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});
</code></pre>
<ul>
<li>relativeTimeThreshold相对时间临界值，例如，超过45秒会被认为是一分钟，超过22小时会被认为是一天</li>
</ul>
<pre><code class="language-js"> // 返回当前使用的临界值
  moment.relativeTimeThreshold('s');  // 45
  moment.relativeTimeThreshold('m');  // 45
  moment.relativeTimeThreshold('h');  // 22
  moment.relativeTimeThreshold('d');  // 26
  moment.relativeTimeThreshold('M');  // 11

  // 设置新的临界值
  moment.relativeTimeThreshold('s', 40);
  moment.relativeTimeThreshold('m', 40);
  moment.relativeTimeThreshold('h', 20);
  moment.relativeTimeThreshold('d', 25);
  moment.relativeTimeThreshold('M', 10);
</code></pre>
<ul>
<li>relativeTimeRounding相对时间近似求值方法</li>
</ul>
<pre><code class="language-js">var roundingDefault = moment.relativeTimeRounding();
// Round relative time evaluation down
moment.relativeTimeRounding(Math.floor);
moment.relativeTimeThreshold('s', 60);
moment.relativeTimeThreshold('m', 60);
moment.relativeTimeThreshold('h', 24);
moment.relativeTimeThreshold('d', 31);
moment.relativeTimeThreshold('M', 12);
var a = moment();
a.subtract({hours: 23, minutes: 59, seconds: 59});
a.toNow()  // == 'in 23 hours'  'Round down towards the nearest hour'
// back to default
moment.relativeTimeRounding(roundingDefault);
</code></pre>
<ul>
<li>moment.now修改默认返回的时间值</li>
</ul>
<pre><code class="language-js">moment.now = function () { return +new Date(); } //默认的方法，你可以自定义自己的方法
</code></pre>
<h2 id="时间段">时间段</h2>
<ol>
<li>创建时间段</li>
</ol>
<pre><code class="language-js">moment.duration(Number, String);
moment.duration(Number);
moment.duration(Object);
moment.duration(String);
</code></pre>
<pre><code class="language-js">moment.duration(100); // 100 毫秒
moment.duration(2, 'seconds'); //也可以传入简写形式s
moment.duration(2, 'minutes');//也可以传入简写形式m
moment.duration(2, 'hours');//也可以传入简写形式h
moment.duration(2, 'days');//也可以传入简写形式d
moment.duration(2, 'weeks');//也可以传入简写形式w
moment.duration(2, 'months');//也可以传入简写形式M
moment.duration(2, 'years');//也可以传入简写形式y
moment.duration({
    seconds: 2,
    minutes: 2,
    hours: 2,
    days: 2,
    weeks: 2,
    months: 2,
    years: 2
});
moment.duration('23:59:59'); //23小时59分59秒
moment.duration('23:59:59.999');//23小时59分59秒999毫秒
moment.duration('7.23:59:59.999');//7天23小时59分59秒999毫秒
</code></pre>
<ol start="2">
<li>克隆时间段</li>
</ol>
<pre><code class="language-js">moment.duration().clone();
</code></pre>
<ol start="3">
<li>人性化</li>
</ol>
<pre><code class="language-js">moment.duration().humanize();
</code></pre>
<ol start="4">
<li>取值</li>
</ol>
<pre><code class="language-js">moment.duration().milliseconds(); //毫秒数
moment.duration().asMilliseconds();//毫秒级别的时间段长度
moment.duration().seconds(); //秒数
moment.duration().asSeconds();//秒级时间段长度
moment.duration().minutes(); //分数
moment.duration().asMinutes();//分钟级别时间段长度
moment.duration().hours();
moment.duration().asHours();
moment.duration().days();
moment.duration().asDays();
moment.duration().months();
moment.duration().asMonths();
moment.duration().years();
moment.duration().asYears();
</code></pre>
<ol start="5">
<li>增加时间，减少时间</li>
</ol>
<pre><code class="language-js">moment.duration().add(Number, String);
moment.duration().add(Number);
moment.duration().add(Duration);
moment.duration().add(Object);
moment.duration().subtract(Number, String);
moment.duration().subtract(Number);
moment.duration().subtract(Duration);
moment.duration().subtract(Object);
</code></pre>
<ol start="6">
<li>使用diff<br>
你可以使用diff和duration获取两个时间点之间的时间段</li>
</ol>
<pre><code class="language-js">var duration = moment.duration(x.diff(y))
</code></pre>
<pre><code class="language-js">var x = new moment()
var y = new moment()
var duration = moment.duration(x.diff(y))
</code></pre>
<ol start="7">
<li>单位转换</li>
</ol>
<pre><code class="language-js">moment.duration().as(String);
</code></pre>
<pre><code class="language-js">duration.as('hours');
duration.as('minutes');
duration.as('seconds');
duration.as('milliseconds');
</code></pre>
<ol start="8">
<li>使用get取值</li>
</ol>
<pre><code class="language-js">moment.duration().get(String);
</code></pre>
<pre><code class="language-js">duration.get('hours');
duration.get('minutes');
duration.get('seconds');
duration.get('milliseconds');
</code></pre>
<ol start="9">
<li>转换为JSON</li>
</ol>
<pre><code class="language-js">moment.duration().toJSON();
</code></pre>
<p>将时间段对象序列化成JSON时，其会按ISO8601标准的字符串进行转换。</p>
<pre><code class="language-js">JSON.stringify({
    postDuration : moment.duration(5, 'm')
}); // '{&quot;postDuration&quot;:&quot;PT5M&quot;}'
</code></pre>
<ol start="10">
<li>是否时间段</li>
</ol>
<pre><code class="language-js">moment.isDuration(obj);
</code></pre>
<pre><code class="language-js">moment.isDuration() // false
moment.isDuration(new Date()) // false
moment.isDuration(moment()) // false
moment.isDuration(moment.duration()) // true
moment.isDuration(moment.duration(2, 'minutes')) // true
</code></pre>
<ol start="11">
<li>转换为As ISO 8601 字符串</li>
</ol>
<pre><code class="language-js">moment.duration().toISOString();
</code></pre>
<ol start="12">
<li>本地化</li>
</ol>
<pre><code class="language-js">moment.duration().locale();
moment.duration().locale(String);
</code></pre>
<pre><code class="language-js">moment.duration(1, &quot;minutes&quot;).locale(&quot;en&quot;).humanize(); // a minute
moment.duration(1, &quot;minutes&quot;).locale(&quot;fr&quot;).humanize(); // une minute
moment.duration(1, &quot;minutes&quot;).locale(&quot;es&quot;).humanize(); // un minuto
</code></pre>
<h2 id="工具类">工具类</h2>
<ol>
<li>标准化单位</li>
</ol>
<pre><code class="language-js">moment.normalizeUnits(String);
</code></pre>
<p>Moment中的很多函数都允许访问器传入单位枚举的别名。例如，下面所有的get都相等。</p>
<pre><code class="language-js">var m = moment();
m.get('y');
m.get('year');
m.get('years');
</code></pre>
<p>如果你正在对类库进行扩展，通过对Moment功能的调整，您可以更容易的访问其中的特性</p>
<pre><code class="language-js">moment.normalizeUnits('y');      // 'year'
moment.normalizeUnits('Y');      // 'year'
moment.normalizeUnits('year');   // 'year'
moment.normalizeUnits('years');  // 'year'
moment.normalizeUnits('YeARS');  // 'year'
</code></pre>
<ol start="2">
<li>无效对象</li>
</ol>
<pre><code class="language-js">moment.invalid(Object);
</code></pre>
<p>你可以创建你自己的无效Moment对象，在这你自己定义的解析器中非常有用。</p>
<pre><code class="language-js">var m = moment.invalid();
m.isValid();                      // false
m.format();                       // 'Invalid date'
m.parsingFlags().userInvalidated; // true
</code></pre>
<p>invalid同样接受对象形式的参数，其中包含对解析标识的一些设置。这不会设置userInvalidated解析标识，除非通过属性指定。</p>
<pre><code class="language-js">var m = moment.invalid({invalidMonth: 'Actober'});
m.parsingFlags().invalidMonth; // 'Actober'
</code></pre>
<p>你不必指定Moment中的解析标识，因为这在Moment中是无效的，转换标识会由<code>parsingFlags()</code>返回。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mongoose学习教程]]></title>
        <id>https://huxinmin.github.io/post/mongoose-xue-xi-jiao-cheng/</id>
        <link href="https://huxinmin.github.io/post/mongoose-xue-xi-jiao-cheng/">
        </link>
        <updated>2020-04-20T07:37:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="why-mongoose">why mongoose?</h2>
<p>在官网上是这样说的，我们开发Mongoose是因为（开发者）写MongoDB的验证机制、类型转换与业务逻辑模板很麻烦。 针对为应用数据建模的问题，Mongoose 提供了一套直白的，基于模式的解决方案。包括了内建的类型转换、验证器、查询构造器、业务逻辑钩子等。</p>
<h2 id="简介">简介</h2>
<p>mongoose是mongoDB的一个对象模型工具，是基于<code>node-mongodb-native</code>开发的mongoDB的nodejs驱动，可以在异步的环境下执行。同时它也是针对mongoDB操作的一个对象模型库，封装了mongoDB对文档的一些增删改查等常用方法，让nodejs操作mongoDB数据库变得更加容易。</p>
<h2 id="安装">安装</h2>
<p>在安装mongoose之前我们需要安装<code>mongodb</code>和<code>nodejs</code>，然后</p>
<pre><code class="language-sh">npm install mongoose
</code></pre>
<p>然后开始建立连接并使用即可：</p>
<pre><code class="language-js">var mongoose = require('mongoose');
mongoose.connect('mongodb://user:pass@localhost:port/database',options);
var conn = mongoose.connection;
conn.on('connected', callback); //连接成功
conn.on('disconnected', callback); //断开连接
conn.on('connecting', callback); //连接中
conn.on('disconnecting', callback); //断开连接中
conn.on('error', callback); //连接异常
</code></pre>
<h2 id="schemas">Schemas</h2>
<p>mongoose中的schema对应于mongodb中的collection，并且定义了这个文档里面的数据模型。</p>
<pre><code class="language-js"> var mongoose = require('mongoose');
  var Schema = mongoose.Schema;
  var blogSchema = new Schema({
    title:  String,
    author: String,
    body:   String,
    comments: [{ body: String, date: Date }],
    date: { type: Date, default: Date.now },
    hidden: Boolean,
    meta: {
      votes: Number,
      favs:  Number
    }
  });
//如果想在后期加入别的数据模型
blogSchema.add({ name: 'string', color: 'string', price: 'number' });
</code></pre>
<p>在定义数据模型的时候，您需要指定每个字段对应的数据类型，mongoose支持以下这些类型：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Date</code></li>
<li><code>Buffer</code></li>
<li><code>Boolean</code></li>
<li><code>Mixed</code></li>
<li><code>ObjectId</code></li>
<li><code>Array</code></li>
<li><code>Decimal128</code></li>
<li><code>Map</code></li>
</ul>
<p>您可以直接指定数据的类型，还可以在指定类型的同时，设置一些选项：</p>
<pre><code class="language-js">var schema1 = new Schema({
  test: String
});
var schema2 = new Schema({
  test: { 
     type: String,
     lowercase: true  //该选项只支持string类型
  }
});
</code></pre>
<p>公共选项列表如下：</p>
<ul>
<li><code>required</code>是否是必须填写的</li>
<li><code>default</code>默认值，可以是一个值或者一个带返回值的函数</li>
<li><code>select</code>布尔值，是否启用Mongodb的<a href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/" target="_blank" rel="nofollow"><code>projection</code></a>功能</li>
<li><code>validate</code>函数，添加验证器</li>
<li><code>get</code>添加getter函数</li>
<li><code>set</code>添加setter函数</li>
<li><code>alias</code>字符类型，定义一个<code>virtual</code><br>
序列选项列表如下：</li>
<li><code>index</code>布尔值，是否为该键建立<a href="https://docs.mongodb.com/manual/indexes/" target="_blank" rel="nofollow">序列</a></li>
<li><code>unique</code>布尔值，是否建议<a href="https://docs.mongodb.com/manual/core/index-unique/" target="_blank" rel="nofollow">唯一序列</a></li>
<li><code>sparse</code>布尔值，是否建立<a href="https://docs.mongodb.com/manual/core/index-sparse/" target="_blank" rel="nofollow">稀疏序列</a><br>
字符串选项列表如下：</li>
<li><code>lowercase</code>布尔值，转换为小写</li>
<li><code>uppercase</code>布尔值，转换为大写</li>
<li><code>trim</code>布尔值，是否使用<code>trim()</code>方法消除空白</li>
<li><code>match</code>正则，检查是否匹配</li>
<li><code>enum</code>数组，检测是否在数组中</li>
<li><code>minlength</code>最小长度</li>
<li><code>maxlength</code>最大长度</li>
</ul>
<p>注意的点：</p>
<ul>
<li>内置的js的Date方法改变mongoose的date类型数据时，保存时无效，必须先调用<code>markModified</code>方法</li>
</ul>
<pre><code class="language-js">var Assignment = mongoose.model('Assignment', { dueDate: Date });
Assignment.findOne(function (err, doc) {
  doc.dueDate.setMonth(3);
  doc.save(callback); // 无效
  doc.markModified('dueDate');
  doc.save(callback); // 有效
})
</code></pre>
<ul>
<li>mixed类型的数据类型如果值改变，也需要先调用<code>markModified</code>方法</li>
</ul>
<pre><code class="language-js">person.anything = { x: [3, 4, { y: &quot;changed&quot; }] };
person.markModified('anything');
person.save();
</code></pre>
<ul>
<li>具化ObjectId的时候需要使用<code>Schema.Types.ObjectId</code></li>
</ul>
<pre><code class="language-js">var ObjectId = mongoose.Schema.Types.ObjectId;
var Car = new Schema({ driver: ObjectId });
</code></pre>
<ul>
<li>map类型的数据需要<code>get()</code>和<code>set()</code>来取值和设置值</li>
</ul>
<pre><code class="language-js">const user = new User({
  socialMediaHandles: {}
});
user.socialMediaHandles.set('github', 'vkarpov15');
user.set('socialMediaHandles.twitter', '@code_barbarian');
console.log(user.socialMediaHandles.get('github'));
console.log(user.get('socialMediaHandles.twitter'));
</code></pre>
<ul>
<li><code>schema.path()</code>可以获得实例化的schema的类型</li>
</ul>
<pre><code class="language-js">var sampleSchema = new Schema({ name: { type: String, required: true } });
console.log(sampleSchema.path('name'));
// 输出如下:
/**
 * SchemaString {
 *   enumValues: [],
 *   regExp: null,
 *   path: 'name',
 *   instance: 'String',
 *   validators: ...
 */
</code></pre>
<p>我们可以在schema上定义一些<code>methods</code>，该方法可以在document上使用(注意不要使用箭头函数，否则无法获取this)</p>
<pre><code class="language-js"> var animalSchema = new Schema({ name: String, type: String });
animalSchema.methods.findSimilarTypes = function(cb) {
    return this.model('Animal').find({ type: this.type }, cb);
};
//或者这样写
animalSchema.method('findSimilarTypes ', function () {})
animalSchema.method({findSimilarTypes : function () {}});
//在Model上使用
var Animal = mongoose.model('Animal', animalSchema);
var dog = new Animal({ type: 'dog' });
dog.findSimilarTypes(function(err, dogs) {
    console.log(dogs); // woof
});
</code></pre>
<p>我们还可以在schema上定义一些<code>statics</code>，该方法可以在model上使用：</p>
<pre><code class="language-js">animalSchema.statics.findByName = function(name, cb) {
    return this.find({ name: new RegExp(name, 'i') }, cb);
  };
var Animal = mongoose.model('Animal', animalSchema);
  Animal.findByName('fido', function(err, animals) {
    console.log(animals);
  });
</code></pre>
<p>我们还可以为查找器增加一些链式帮助函数</p>
<pre><code class="language-js"> animalSchema.query.byName = function(name) {
    return this.where({ name: new RegExp(name, 'i') });
  };
var Animal = mongoose.model('Animal', animalSchema);
  Animal.find().byName('fido').exec(function(err, animals) {
    console.log(animals);
  });
</code></pre>
<p>mongoose默认会为每个schema建立一个自动索引，不过在生产环境建议关掉，有如下这些方法：</p>
<pre><code class="language-js"> mongoose.connect('mongodb://user:pass@localhost:port/database', { autoIndex: false });
  mongoose.createConnection('mongodb://user:pass@localhost:port/database', { autoIndex: false });
  animalSchema.set('autoIndex', false);
  new Schema({..}, { autoIndex: false });
</code></pre>
<p>您还可以为schema设置虚拟的属性，该属性不会保存在数据库中，但是在你取值设置值的时候，可以分解或者合并属性值：</p>
<pre><code class="language-js">var personSchema = new Schema({
    name: {
      first: String,
      last: String
    }
  });
  var Person = mongoose.model('Person', personSchema);
  var axl = new Person({
    name: { first: 'Axl', last: 'Rose' }
  });
personSchema.virtual('fullName').get(function () {
  return this.name.first + ' ' + this.name.last;
});
console.log(axl.fullName); // Axl Rose
</code></pre>
<p>注意要对虚拟属性进行<code>toJSON()</code> or<code>toObject()</code>转换时需要传递<code>{ virtuals: true }</code>参数进来才行。</p>
<p>你还可以使用<code>alias</code>为属性名设置别名</p>
<pre><code class="language-js">var personSchema = new Schema({
  n: {
    type: String,
    alias: 'name'
  }
})
var person = new Person({ name: 'Val' });
console.log(person); // { n: 'Val' }
console.log(person.toObject({ virtuals: true })); // { n: 'Val', name: 'Val' }
</code></pre>
<p>注意如果是嵌套属性，需要设置嵌套路径</p>
<pre><code class="language-js">const parentSchema = new Schema({
  name: {
    f: {
      type: String,
      alias: 'name.first'
    }
  }
});
</code></pre>
<p>您还可以为schema设置选项，语法如下：</p>
<pre><code class="language-js">new Schema({..}, options);
//或者
var schema = new Schema({..});
schema.set(option, value);
</code></pre>
<p>它有如下这些选项：</p>
<ul>
<li><code>autoIndex</code>布尔值，是否开启自动索引</li>
<li><code>bufferCommands</code>布尔值，当连接挂掉重连之前是否缓冲命令</li>
<li><code>capped</code>数值，使用固定大小collection</li>
<li><code>collection</code>字符串，为collection设置不同的名字</li>
<li><code>id</code>布尔值，关闭默认的虚拟属性<code>id</code>值（返回的其实是_id）</li>
<li><code>_id</code>布尔值，关闭<code>_id</code>值（将会导致无法保存）</li>
<li><code>minimize</code>布尔值，设为false会保存空对象</li>
<li><code>read</code>设置query的read的优先级</li>
<li><code>writeConcern</code><a href="https://docs.mongodb.com/manual/reference/write-concern/" target="_blank" rel="nofollow">在schema级别设置write concern</a></li>
<li><code>safe</code>遗留api，与writeConcern相同</li>
<li><code>shardKey</code>设置分片key值</li>
<li><code>strict</code>布尔值，规定在schema中没有定义的key不会被保存</li>
<li><code>strictQuery</code>为filter设置query</li>
<li><code>toJSON</code>转换为json对象与toObject相同，但是需要显示调用</li>
<li><code>toObject</code>转换为Json对象</li>
</ul>
<pre><code class="language-js">var schema = new Schema({ name: String });
schema.path('name').get(function (v) {
  return v + ' is my name';
});
schema.set('toJSON', { getters: true, virtuals: false });
var M = mongoose.model('Person', schema);
var m = new M({ name: 'Max Headroom' });
schema.set('toObject', { getters: true });
console.log(m.toJSON());// { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }
console.log(m); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }
</code></pre>
<ul>
<li><code>typeKey</code>默认的，mongoose会将<code>type</code>字符串当做Mongoose的type解释，如果需要当做属性进行解释，需要设置typeKey</li>
</ul>
<pre><code class="language-js">var schema = new Schema({
  // Mongoose interpets this as 'loc is an object with 2 keys, type and coordinates'
  loc: { type: String, coordinates: [Number] },
  // Mongoose interprets this as 'name is a String'
  name: { $type: String }
}, { typeKey: '$type' }); // A '$type' key means this object is a type declaration
</code></pre>
<ul>
<li>validateBeforeSave手动控制是否在保存之前进行验证</li>
</ul>
<pre><code class="language-js">var schema = new Schema({ name: String });
schema.set('validateBeforeSave', false);
</code></pre>
<ul>
<li><code>versionKey</code>自定义版本控制</li>
<li><code>collation</code><a href="https://docs.mongodb.com/manual/reference/collation/" target="_blank" rel="nofollow">设置校验</a></li>
<li><code>skipVersioning</code>忽略版本管理</li>
<li><code>timestamps</code>设置时间戳，默认为createdAt 和updatedAt</li>
<li><code>useNestedStrict</code>设置嵌套schema的更新规则</li>
</ul>
<h2 id="连接">连接</h2>
<p>您可以使用下面的语法来连接mongodb:</p>
<pre><code class="language-js">mongoose.connect('mongodb://username:password@host:port/database?options...',options);
</code></pre>
<p>options有一下选项：</p>
<ul>
<li><code>bufferCommands</code></li>
<li><code>user/pass</code></li>
<li><code>autoIndex</code></li>
<li><code>dbName</code></li>
<li><code>autoReconnect</code></li>
<li><code>reconnectTries</code></li>
<li><code>reconnectInterval</code></li>
<li><code>promiseLibrary</code></li>
<li><code>poolSize</code></li>
<li><code>bufferMaxEntries</code></li>
<li><code>connectTimeoutMS</code></li>
<li><code>socketTimeoutMS</code></li>
</ul>
<h2 id="models">Models</h2>
<p>Models是用来创建和读写数据库的，它的一个实例就是document。</p>
<pre><code class="language-js">var Tank = mongoose.model('Tank', yourSchema);
//第一种方法
var small = new Tank({ size: 'small' });
small.save(function (err) {
  if (err) return handleError(err);
  // saved!
});
// 第二种方法
Tank.create({ size: 'small' }, function (err, small) {
  if (err) return handleError(err);
  // saved!
});
// 第三种方法
Tank.insertMany([{ size: 'small' }], function(err) {

});
</code></pre>
<p>注意每一个model都有对应的连接，如果使用的是<code>mongoose.model()</code>,则对应<code>mongoose.connect('localhost', 'gettingstarted');</code>如果使用的是自定义的连接，则使用</p>
<pre><code class="language-js">var connection = mongoose.createConnection('mongodb://localhost:27017/test');
var Tank = connection.model('Tank', yourSchema);
</code></pre>
<p>常用查询操作：</p>
<ul>
<li><code>deleteMany()</code></li>
<li><code>deleteOne()</code></li>
<li><code>find()</code></li>
<li><code>findById()</code></li>
<li><code>findByIdAndDelete()</code></li>
<li><code>findByIdAndRemove()</code></li>
<li><code>findByIdAndUpdate()</code></li>
<li><code>findOne()</code></li>
<li><code>findOneAndDelete()</code></li>
<li><code>findOneAndRemove()</code></li>
<li><code>findOneAndUpdate()</code></li>
<li><code>replaceOne()</code></li>
<li><code>updateMany()</code></li>
<li><code>updateOne()</code></li>
</ul>
<p>这些方法都有两种方法，一种是直接使用回调函数，另一种是使用<code>.then()</code>链式调用（不同于真正的promise，mongoose返回的查询不能使用多次then，否则会执行多次），当数据改变的时候，您还可以使用<code>model.watch</code>来进行观察：</p>
<pre><code class="language-js">async function run() {
  // Create a new mongoose model
  const personSchema = new mongoose.Schema({
    name: String
  });
  const Person = mongoose.model('Person', personSchema, 'Person');
  // Create a change stream. The 'change' event gets emitted when there's a
  // change in the database
  Person.watch().
    on('change', data =&gt; console.log(new Date(), data));
  // Insert a doc, will trigger the change stream handler above
  console.log(new Date(), 'Inserting doc');
  await Person.create({ name: 'Axl Rose' });
}
2018-05-11T15:05:35.467Z 'Inserting doc'
2018-05-11T15:05:35.487Z 'Inserted doc'
2018-05-11T15:05:35.491Z { _id: { _data: ... },
  operationType: 'insert',
  fullDocument: { _id: 5af5b13fe526027666c6bf83, name: 'Axl Rose', __v: 0 },
  ns: { db: 'test', coll: 'Person' },
  documentKey: { _id: 5af5b13fe526027666c6bf83 } }
</code></pre>
<p>您不仅可以把查询的条件一次性全部写在查询json中，还可以使用链式方式书写，下面的写法都是相等的：</p>
<pre><code class="language-js">Person.
  find({
    occupation: /host/,
    'name.last': 'Ghost',
    age: { $gt: 17, $lt: 66 },
    likes: { $in: ['vaporizing', 'talking'] }
  }).
  limit(10).
  sort({ occupation: -1 }).
  select({ name: 1, occupation: 1 }).
  exec(callback);
// 相等的写法
Person.
  find({ occupation: /host/ }).
  where('name.last').equals('Ghost').
  where('age').gt(17).lt(66).
  where('likes').in(['vaporizing', 'talking']).
  limit(10).
  sort('-occupation').
  select('name occupation').
  exec(callback);
</code></pre>
<p>您还可以为查询方法设置一些钩子函数，使用<code>cursor()</code>即可，有两种方法，第一种使用stream调用，第二种使用<code>next</code>手动调用：</p>
<pre><code class="language-js">// There are 2 ways to use a cursor. First, as a stream:
Thing.
  find({ name: /^hello/ }).
  cursor().
  on('data', function(doc) { console.log(doc); }).
  on('end', function() { console.log('Done!'); });
// Or you can use `.next()` to manually get the next doc in the stream.
// `.next()` returns a promise, so you can use promises or callbacks.
var cursor = Thing.find({ name: /^hello/ }).cursor();
cursor.next(function(error, doc) {
  console.log(doc);
});
</code></pre>
<h2 id="subdocuments">subdocuments</h2>
<p>documents代表存储在mongodb中的实际数据，每一个document都是model的一个实例。subdocuments就是嵌套在其他documents中的子文档。mongoose中有两种子文档类型，一种是数组，一种是单个文档：</p>
<pre><code class="language-js">var parentSchema = new Schema({
  // Array of subdocuments
  children: [childSchema],
  // Single nested subdocuments. Caveat: single nested subdocs only work
  // in mongoose &gt;= 4.2.0
  child: childSchema
});
</code></pre>
<p>subdocuments和documents之间的主要不同就是，subdocuments不单独保存，只要父级documents保存了，它就会被保存。子文档的<code>pre('save')</code>和<code>pre('validate')</code>会在父文档的<code>pre('save')</code>之前，<code>pre('validate')</code>之后执行。您可以使用<code>_id</code>查找子文档：</p>
<pre><code class="language-js">var doc = parent.children.id(_id);
</code></pre>
<p>您可以使用push，unshift，addToSet来对子文档数组操作，或者直接使用create方法：</p>
<pre><code class="language-js">var Parent = mongoose.model('Parent');
var parent = new Parent;
// create a comment
parent.children.push({ name: 'Liesl' });
var subdoc = parent.children[0];
console.log(subdoc) // { _id: '501d86090d371bab2c0341c5', name: 'Liesl' }
subdoc.isNew; // true
parent.save(function (err) {
  if (err) return handleError(err)
  console.log('Success!');
});
//或者
var newdoc = parent.children.create({ name: 'Aaron' });
</code></pre>
<p>当您想要删除子文档时，可以使用<code>remove</code>方法：</p>
<pre><code class="language-js">// Equivalent to `parent.children.pull(_id)`
parent.children.id(_id).remove();
// Equivalent to `parent.child = null`
parent.child.remove();
</code></pre>
<h2 id="验证">验证</h2>
<p>在mongoose中，数据的每次操作都需要进行验证，这样就可以防止一些恶意注入等危害。验证是在schema中定义的，且是middleware。</p>
<p>Mongoose中有一些内置的验证器：</p>
<ul>
<li><code>required</code></li>
<li><code>Numbers</code>有<code>min</code>和<code>max</code>验证器</li>
<li><code>Strings</code>有<code>enum</code>, <code>match</code>, <code>maxlength</code> and <code>minlength</code>验证器</li>
</ul>
<p>如果想要自定义你自己的验证器，可以加入<code>validate</code>属性：</p>
<pre><code class="language-js">var userSchema = new Schema({
  phone: {
    type: String,
    validate: {
      validator: function(v) {
        return /\d{3}-\d{3}-\d{4}/.test(v);
      },
      message: '{VALUE} is not a valid phone number!'
    },
    required: [true, 'User phone number required']
  }
});
var User = db.model('user', userSchema);
var user = new User();
var error;
user.phone = '555.0123';
error = user.validateSync();
assert.equal(error.errors['phone'].message,
  '555.0123 is not a valid phone number!');
</code></pre>
<p>您还有可以设置异步的验证器：</p>
<pre><code class="language-js">var userSchema = new Schema({
  name: {
    type: String,
    // You can also make a validator async by returning a promise. If you
    // return a promise, do **not** specify the `isAsync` option.
    validate: function(v) {
      return new Promise(function(resolve, reject) {
        setTimeout(function() {
          resolve(false);
        }, 5);
      });
    }
  },
  phone: {
    type: String,
    validate: {
      isAsync: true,
      validator: function(v, cb) {
        setTimeout(function() {
          var phoneRegex = /\d{3}-\d{3}-\d{4}/;
          var msg = v + ' is not a valid phone number!';
          // First argument is a boolean, whether validator succeeded
          // 2nd argument is an optional error message override
          cb(phoneRegex.test(v), msg);
        }, 5);
      },
      // Default error message, overridden by 2nd argument to `cb()` above
      message: 'Default error message'
    },
    required: [true, 'User phone number required']
  }
});
</code></pre>
<p>如果想要在<code>update()</code>或者<code>findOneAndUpdate()</code>中开启验证的话，需要设置<code>runValidators</code>:</p>
<pre><code class="language-js">var toySchema = new Schema({
  color: String,
  name: String
});
var Toy = db.model('Toys', toySchema);
Toy.schema.path('color').validate(function (value) {
  return /blue|green|white|red|orange|periwinkle/i.test(value);
}, 'Invalid color');
var opts = { runValidators: true };
Toy.update({}, { color: 'bacon' }, opts, function (err) {
  assert.equal(err.errors.color.message,
    'Invalid color');
});
</code></pre>
<p><code>update</code>验证器和<code>document</code>验证器有几点区别：</p>
<ul>
<li>update验证器this未定义,document验证器this指向该document，不过你可以在update验证器上通过设置context设置this指向该查询</li>
<li>update验证器只验证对应的路径</li>
<li>update验证器只在一些操作符时候运行，<code>$set</code>，<code>$unset</code>，<code>$push (&gt;= 4.8.0)</code>，<code>$addToSet (&gt;= 4.8.0)</code>，<code>$pull (&gt;= 4.12.0)</code>，<code>$pullAll (&gt;= 4.12.0)</code></li>
</ul>
<h2 id="middleware">Middleware</h2>
<p>Mongoose有4种中间件：</p>
<ul>
<li>document 中间件：
<ul>
<li><code>init</code></li>
<li><code>validate</code></li>
<li><code>save</code></li>
<li><code>remove</code></li>
</ul>
</li>
<li>model 中间件：
<ul>
<li><code>count</code></li>
<li><code>find</code></li>
<li><code>findOne</code></li>
<li><code>findOneAndRemove</code></li>
<li><code>findOneAndUpdate</code></li>
<li><code>update</code></li>
<li><code>updateOne</code></li>
<li><code>updateMany</code></li>
</ul>
</li>
<li><code>aggregate</code> 中间件：
<ul>
<li><code>aggregate</code></li>
</ul>
</li>
<li><code>query</code> 中间件：
<ul>
<li><code>insertMany</code></li>
</ul>
</li>
</ul>
<p>有两种钩子函数，一种是串行的，一种是并行的，在串行中，你可以使用<code>next</code>来执行下一步，或者返回一个promise函数，pre表示之前，post表示之后：</p>
<pre><code class="language-js">var schema = new Schema(..);
schema.pre('save', function(next) {
  // do stuff
  next();
});
schema.pre('save', function() {
  return doStuff().
    then(() =&gt; doMoreStuff());
});
// Or, in Node.js &gt;= 7.6.0:
schema.pre('save', async function() {
  await doStuff();
  await doMoreStuff();
});
</code></pre>
<p>并行的提供了更加细粒度的流控制：</p>
<pre><code class="language-js">var schema = new Schema(..);
// 第二个参数设置为true表示并行
schema.pre('save', true, function(next, done) {
  // calling next kicks off the next middleware in parallel
  next();
  setTimeout(done, 100);
});
</code></pre>
<p>注意post和pre不会在update(), findOneAndUpdate()上执行。</p>
<h2 id="populate">Populate</h2>
<p>population是一个自动把document中的路径转换为对应的document的过程，使用<code>ref</code>指向即可：</p>
<pre><code class="language-js">var mongoose = require('mongoose');
var Schema = mongoose.Schema;
var personSchema = Schema({
  _id: Schema.Types.ObjectId,
  name: String,
  age: Number,
  stories: [{ type: Schema.Types.ObjectId, ref: 'Story' }]
});
var storySchema = Schema({
  author: { type: Schema.Types.ObjectId, ref: 'Person' },
  title: String,
  fans: [{ type: Schema.Types.ObjectId, ref: 'Person' }]
});
var Story = mongoose.model('Story', storySchema);
var Person = mongoose.model('Person', personSchema);
</code></pre>
<p>注意ObjectId, Number, String, and Buffer都是合法的ref类型，但是对于新手最好只使用ObjectId。</p>
<p>然后在查询的时候，我们就可以<code>populate</code>将对应的数据整合进来：</p>
<pre><code class="language-js">Story.
  findOne({ title: 'Casino Royale' }).
  populate('author').
  exec(function (err, story) {
    if (err) return handleError(err);
    console.log('The author is %s', story.author.name);
    // prints &quot;The author is Ian Fleming&quot;
  });
</code></pre>
<p>如果只想整合一些域的话，可以在populate的第二个参数中写入要选择的字段，如果是多个的话可以用空格分开：</p>
<pre><code class="language-js">Story.
  findOne({ title: /casino royale/i }).
  populate('author', 'name'). // only return the Persons name
  exec(function (err, story) {})
</code></pre>
<p>如果想要整合多个ref的话，可以连续调用(如果对同一个ref设置多个，则只有最后一个生效)</p>
<pre><code class="language-js">Story.
  find(...).
  populate('fans').
  populate('author').
  exec();
</code></pre>
<p>如果想要更精细化的控制，还可以给populate传入一个对象：</p>
<pre><code class="language-js">Story.
  find(...).
  populate({
    path: 'fans',
    match: { age: { $gte: 21 }},
    // Explicitly exclude `_id`, see http://bit.ly/2aEfTdB
    select: 'name -_id',
    options: { limit: 5 }
  }).
  exec();
</code></pre>
<p>如果你想要populate文档下面的populate对象，则：</p>
<pre><code class="language-js">User.
  findOne({ name: 'Val' }).
  populate({
    path: 'friends',
    // Get friends of friends - populate the 'friends' array for every friend
    populate: { path: 'friends' }
  });
</code></pre>
<p>跨数据库populate:</p>
<pre><code class="language-js">var eventSchema = new Schema({
  name: String,
  // The id of the corresponding conversation
  // Notice there's no ref here!
  conversation: ObjectId
});
var conversationSchema = new Schema({
  numMessages: Number
});
var db1 = mongoose.createConnection('localhost:27000/db1');
var db2 = mongoose.createConnection('localhost:27001/db2');
var Event = db1.model('Event', eventSchema);
var Conversation = db2.model('Conversation', conversationSchema);
Event.
  find().
  populate({ path: 'conversation', model: Conversation }).
  exec(function(error, docs) { /* ... */ });
</code></pre>
<p>您还可以通过设置<code>refPath</code>来设置动态的ref:</p>
<pre><code class="language-js">var userSchema = new Schema({
  name: String,
  connections: [{
    kind: String,
    item: { type: ObjectId, refPath: 'connections.kind' }
  }]
});
</code></pre>
<p>只在_id中设置ref不是最好的选择，您还可以在virtuals中进行设置：</p>
<pre><code class="language-js">var PersonSchema = new Schema({
  name: String,
  band: String
});
var BandSchema = new Schema({
  name: String
});
BandSchema.virtual('members', {
  ref: 'Person', // The model to use
  localField: 'name', // 找到本地字段 `localField`与对应model字段`foreignField`值相等的document
  foreignField: 'band', 
  // If `justOne` is true, 'members' will be a single doc as opposed to
  // an array. `justOne` is false by default.
  justOne: false
});
</code></pre>
<p>注意<code>toJSON()</code>不包含在virtuals 中，所以需要手动设置：</p>
<pre><code class="language-js">var BandSchema = new Schema({
  name: String
}, { toJSON: { virtuals: true } });
</code></pre>
<p>然后使用,注意<code>foreignField</code>必须包含在populate中：</p>
<pre><code class="language-js">Band.
  find({}).
  populate({ path: 'members', select: 'name band' }).
  exec(function(error, bands) {
    // Works, foreign field `band` is selected
  });
</code></pre>
<p>您还可以在中间件中使用populate:</p>
<pre><code class="language-js">MySchema.pre('find', function() {
  this.populate('user');
});
MySchema.post('find', async function(docs) {
  for (let doc of docs) {
    if (doc.isPublic) {
      await doc.populate('user').execPopulate();
    }
  }
});
MySchema.post('save', function(doc, next) {
  doc.populate('user').execPopulate(function() {
    next();
  });
});
</code></pre>
<h2 id="discriminators">Discriminators</h2>
<p>Discriminators 是一个schema的继承机制，可以使得你拥有多个models使用了重叠的schema在同一个collection下面。例如你可以使用<code>model.discriminator()</code>来整合一个基础的schema和一个Discriminator schema：</p>
<pre><code class="language-js">var options = {discriminatorKey: 'kind'};
var eventSchema = new mongoose.Schema({time: Date}, options);
var Event = mongoose.model('Event', eventSchema);
// ClickedLinkEvent is a special type of Event that has
// a URL.
var ClickedLinkEvent = Event.discriminator('ClickedLink',
  new mongoose.Schema({url: String}, options));
// When you create a generic event, it can't have a URL field...
var genericEvent = new Event({time: Date.now(), url: 'google.com'});
assert.ok(!genericEvent.url);
// But a ClickedLinkEvent can
var clickedEvent =
  new ClickedLinkEvent({time: Date.now(), url: 'google.com'});
</code></pre>
<p>mongoose分辨不同的Discriminators 是通过<code>__t</code>来区分的，而且Discriminators 都可以很智能地通过<code>find()</code>, <code>count()</code>, <code>aggregate()</code>来找到数量：</p>
<pre><code class="language-js">var event1 = new Event({time: Date.now()});
var event2 = new ClickedLinkEvent({time: Date.now(), url: 'google.com'});
var event3 = new SignedUpEvent({time: Date.now(), user: 'testuser'});
var save = function (doc, callback) {
  doc.save(function (error, doc) {
    callback(error, doc);
  });
};
async.map([event1, event2, event3], save, function (error) {
  ClickedLinkEvent.find({}, function (error, docs) {
    assert.equal(docs.length, 1);
    assert.equal(docs[0]._id.toString(), event2._id.toString());
    assert.equal(docs[0].url, 'google.com');
  });
});
</code></pre>
<p>Discriminators 可以使用基础的schema的中间件，但是你也可以为它添加自己的中间件而不影响基础的schema:</p>
<pre><code class="language-js">var options = {discriminatorKey: 'kind'};
var eventSchema = new mongoose.Schema({time: Date}, options);
var eventSchemaCalls = 0;
eventSchema.pre('validate', function (next) {
  ++eventSchemaCalls;
  next();
});
var Event = mongoose.model('GenericEvent', eventSchema);
var clickedLinkSchema = new mongoose.Schema({url: String}, options);
var clickedSchemaCalls = 0;
clickedLinkSchema.pre('validate', function (next) {
  ++clickedSchemaCalls;
  next();
});
var ClickedLinkEvent = Event.discriminator('ClickedLinkEvent',
  clickedLinkSchema);
var event1 = new ClickedLinkEvent();
event1.validate(function() {
  assert.equal(eventSchemaCalls, 1);
  assert.equal(clickedSchemaCalls, 1);
  var generic = new Event();
  generic.validate(function() {
    assert.equal(eventSchemaCalls, 2);
    assert.equal(clickedSchemaCalls, 1);
  });
});
</code></pre>
<p>当你使用<code>Model.create()</code>自动创建时，mongoose会自动为您选择适合的Discriminator进行创建：</p>
<pre><code class="language-js">var Schema = mongoose.Schema;
var shapeSchema = new Schema({
  name: String
}, { discriminatorKey: 'kind' });
var Shape = db.model('Shape', shapeSchema);
var Circle = Shape.discriminator('Circle',
  new Schema({ radius: Number }));
var Square = Shape.discriminator('Square',
  new Schema({ side: Number }));
var shapes = [
  { name: 'Test' },
  { kind: 'Circle', radius: 5 },
  { kind: 'Square', side: 10 }
];
Shape.create(shapes, function(error, shapes) {
  assert.ifError(error);
  assert.ok(shapes[0] instanceof Shape);
  assert.ok(shapes[1] instanceof Circle);
  assert.equal(shapes[1].radius, 5);
  assert.ok(shapes[2] instanceof Square);
  assert.equal(shapes[2].side, 10);
});
</code></pre>
<h2 id="常用api">常用API</h2>
<ul>
<li>
<p>Model</p>
<ul>
<li><code>Model.count()</code>找到符合条件的文档数量，已经废弃</li>
<li><code>Model.countDocuments()</code>找到符合条件的文档数量</li>
<li><code>Model.create()</code>创建一个或多个文档，<code>MyModel.create(docs)</code>等同于多个<code>new MyModel(doc).save()</code></li>
<li><code>Model.deleteMany()</code>删除多个</li>
<li><code>Model.deleteOne()</code>删除一个</li>
<li><code>Model.distinct()</code>查找所有文档中某个字段的不重复值，返回去重后的字段所有值</li>
<li><code>Model.find()</code></li>
<li><code>Model.findById()</code></li>
<li><code>Model.findByIdAndDelete()</code></li>
<li><code>Model.findByIdAndRemove()</code></li>
<li><code>Model.findByIdAndUpdate()</code></li>
<li><code>Model.findOne()</code></li>
<li><code>Model.findOneAndDelete()</code></li>
<li><code>Model.findOneAndRemove()</code></li>
<li><code>Model.findOneAndUpdate()</code></li>
<li><code>Model.insertMany()</code></li>
<li><code>Model.populate()</code></li>
<li><code>Model.prototype.$where()</code>创建一个查询</li>
</ul>
<pre><code class="language-js">Blog.$where('this.username.indexOf(&quot;val&quot;) !== -1').exec();
</code></pre>
<ul>
<li><code>Model.prototype.remove()</code></li>
<li><code>Model.prototype.save()</code></li>
<li><code>Model.remove()</code></li>
<li><code>Model.replaceOne()</code></li>
<li><code>Model.update()</code>更新文档但是不返回该数据</li>
<li><code>Model.updateMany()</code></li>
<li><code>Model.updateOne()</code></li>
<li><code>Model.where()</code>查询</li>
</ul>
<pre><code class="language-js">User.where('age').gte(21).lte(65).exec(callback);
</code></pre>
</li>
<li>
<p>Document</p>
<ul>
<li><code>Document.prototype.$ignore()</code>不允许验证器，不保留改动某个字段</li>
<li><code>Document.prototype.$isDefault()</code>判断某个字段是否设置默认值</li>
<li><code>Document.prototype.$isDeleted()</code>判断是否移除</li>
<li><code>Document.prototype.depopulate()</code>进行populate的逆运算</li>
<li><code>Document.prototype.get()</code>取值</li>
<li><code>Document.prototype.invalidate()</code>将字段标记为不合格，触发验证失败</li>
<li><code>Document.prototype.populate()</code>整合ref</li>
<li><code>Document.prototype.populated()</code>返回整合的ref的<code>_id</code></li>
<li><code>Document.prototype.save()</code>保存</li>
<li><code>Document.prototype.set()</code>设置值</li>
<li><code>Document.prototype.toJSON()</code>转换为json</li>
<li><code>Document.prototype.toObject()</code>转换为plainObject</li>
<li><code>Document.prototype.update()</code>更新文档</li>
<li><code>Document.prototype.validate()</code>执行验证器</li>
<li><code>Document.prototype.validateSync()</code>同步执行验证器</li>
</ul>
</li>
<li>
<p>Query</p>
<ul>
<li><code>Query.prototype.$where()</code>执行一个函数或表达式查询</li>
</ul>
</li>
</ul>
<pre><code class="language-js">query.$where('this.comments.length === 10 || this.name.length === 5')
// or
query.$where(function () {
  return this.comments.length === 10 || this.name.length === 5;
})
</code></pre>
<ul>
<li><code>Query.prototype.countDocuments()</code>查询数量</li>
<li><code>Query.prototype.deleteMany()</code></li>
<li><code>Query.prototype.deleteOne()</code></li>
<li><code>Query.prototype.distinct()</code></li>
<li><code>Query.prototype.elemMatch()</code>嵌套查询使用，替代find查询嵌套字段写<code>path.path</code></li>
<li><code>Query.prototype.equals()</code>查询时候值等于</li>
<li><code>Query.prototype.exec()</code>执行查询</li>
<li><code>Query.prototype.exists()</code>判断是否存在某个字段</li>
<li><code>Query.prototype.find()</code></li>
<li><code>Query.prototype.findOne()</code></li>
<li><code>Query.prototype.findOneAndDelete()</code></li>
<li><code>Query.prototype.findOneAndRemove()</code></li>
<li><code>Query.prototype.findOneAndUpdate()</code></li>
<li><code>Query.prototype.getQuery()</code>返回查询条件，使用json格式表示出来</li>
<li><code>Query.prototype.getUpdate()</code>返回更新条件，使用json格式表示</li>
<li><code>Query.prototype.gt()</code></li>
<li><code>Query.prototype.gte()</code></li>
<li><code>Query.prototype.lean()</code>查询后的结果如果使用了lean将不再有save等doc的方法</li>
<li><code>Query.prototype.limit()</code></li>
<li><code>Query.prototype.lt()</code></li>
<li><code>Query.prototype.lte()</code></li>
<li><code>Query.prototype.nor()</code>都不是</li>
</ul>
<pre><code class="language-js">query.nor([{ color: 'green' }, { status: 'ok' }])
</code></pre>
<ul>
<li><code>Query.prototype.or()</code>两个中一个</li>
</ul>
<pre><code class="language-js">query.or([{ color: 'red' }, { status: 'emergency' }])
</code></pre>
<ul>
<li><code>Query.prototype.populate()</code></li>
<li><code>Query.prototype.regex()</code>正则查询</li>
<li><code>Query.prototype.remove()</code></li>
<li><code>Query.prototype.select()</code>选择需要展示或者排除的字段，如果是字符可以用<code>+</code>表示包含，<code>-</code>表示排除，对象可以用<code>1</code>表示包含，<code>0</code>表示排除</li>
</ul>
<pre><code class="language-js">query.select('a b');
query.select('-c -d');
query.select({ a: 1, b: 1 });
query.select({ c: 0, d: 0 });
</code></pre>
<ul>
<li><code>Query.prototype.set()</code></li>
<li><code>Query.prototype.setOptions()</code></li>
<li><code>Query.prototype.skip()</code></li>
<li><code>Query.prototype.slice()</code></li>
<li><code>Query.prototype.sort()</code>排序，当你使用object时，可以指定<code>asc</code>, <code>desc</code>, <code>ascending</code>, <code>descending</code>, <code>1</code>, and <code>-1</code>，如果是字符串，默认是升序，使用<code>-</code>来降序：</li>
</ul>
<pre><code class="language-js">// sort by &quot;field&quot; ascending and &quot;test&quot; descending
query.sort({ field: 'asc', test: -1 });
// equivalent
query.sort('field -test');
</code></pre>
<ul>
<li><code>Query.prototype.then()</code></li>
<li><code>Query.prototype.update()</code></li>
<li><code>Query.prototype.updateMany()</code></li>
<li><code>Query.prototype.updateOne()</code></li>
<li><code>Query.prototype.where()</code></li>
</ul>
<h2 id="实例">实例</h2>
<p>分页：</p>
<pre><code class="language-js">model.find(queryCondition).limit(limit).skip(limit*page).exec(function(err, results){
      ...
    });
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://mongoosejs.com/docs/" target="_blank" rel="nofollow">http://mongoosejs.com/docs/</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[console.log 格式化输出详解]]></title>
        <id>https://huxinmin.github.io/post/consolelog-ge-shi-hua-shu-chu-xiang-jie/</id>
        <link href="https://huxinmin.github.io/post/consolelog-ge-shi-hua-shu-chu-xiang-jie/">
        </link>
        <updated>2020-04-20T07:36:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在Js的调试输出时，我们经常看到这样的写法：</p>
<pre><code class="language-js">console.log('%s ...', 'string')
//string...
</code></pre>
<p>其实这是使用了格式化输出的用法，今天我们就来学习一下，在Js中的格式化输出。</p>
<h2 id="格式化输出符号种类">格式化输出符号种类</h2>
<h4 id="s格式化成字符串输出"><code>%s</code>格式化成字符串输出</h4>
<pre><code class="language-js">console.log('%s456', '123') //123456
</code></pre>
<h4 id="d格式化成数值输出"><code>%d</code>格式化成数值输出</h4>
<pre><code class="language-js">console.log('%d456', 123) //123456
console.log('%d456', '123') //NaN456
</code></pre>
<h4 id="i格式化成数值输出"><code>%i</code>格式化成数值输出</h4>
<pre><code class="language-js">console.log('%d456', 123) //123456
console.log('%d456', '123') //NaN456
</code></pre>
<h4 id="o转化成展开的dom元素输出"><code>%o</code>转化成展开的DOM元素输出</h4>
<pre><code class="language-js">console.log('%o', document.body) // body dom元素
</code></pre>
<h4 id="o转化成javascript对象输出"><code>%O</code>转化成JavaScript对象输出</h4>
<pre><code class="language-js">console.log('%O', new Date()) // 日期对象
</code></pre>
<h4 id="c把字符串按照你提供的样式格式化后输入"><code>%c</code>把字符串按照你提供的样式格式化后输入</h4>
<pre><code class="language-js">console.log('%c 123', 'color:red') //输出红色的 123
</code></pre>
<h4 id="f格式化成浮点数值输出"><code>%f</code>格式化成浮点数值输出</h4>
<pre><code class="language-js">console.log('%f', 12.01) //12.01
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Express之cookie session研究]]></title>
        <id>https://huxinmin.github.io/post/express-zhi-cookie-session-yan-jiu/</id>
        <link href="https://huxinmin.github.io/post/express-zhi-cookie-session-yan-jiu/">
        </link>
        <updated>2020-04-20T07:34:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近在研究Express的源码，查看他的依赖项，关于cookie与session的依赖项一共有5个，这些依赖项具体都是做什么的呢，于是我就去研究了一下。</p>
<h2 id="准备知识">准备知识</h2>
<h4 id="http-cookie">http cookie</h4>
<p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
<p>当服务器收到HTTP请求时，服务器可以在响应头里面添加一个<code>Set-Cookie</code>选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<pre><code class="language-js">Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;
</code></pre>
<p>返回信息如下：</p>
<pre><code class="language-sh">HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
...
[页面内容]
</code></pre>
<p>现在再向服务端发起请求则请求会如下：</p>
<pre><code class="language-sh">GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
</code></pre>
<p>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用Cookie的 Secure 标记。</p>
<p>为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>
<p>Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。</p>
<p>Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名。</p>
<p>例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。</p>
<p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p>
<ul>
<li><code>/docs</code></li>
<li><code>/docs/Web/</code></li>
<li><code>/docs/Web/HTTP</code></li>
</ul>
<h4 id="set-cookie"><code>set-cookie</code></h4>
<p>响应首部 <code>Set-Cookie</code> 被用来由服务器端向客户端发送 cookie。<br>
语法：</p>
<pre><code class="language-js">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;;[options] 
</code></pre>
<p>其中<code>options</code>可以有下列这些值：</p>
<ul>
<li><code>Expires=&lt;date&gt;</code>过期时间</li>
<li><code>Max-Age=&lt;non-zero-digit&gt;</code>cookie失效之前需要经过的秒数</li>
<li><code>Domain=&lt;domain-value&gt;</code>主机名</li>
<li><code>Path=&lt;path-value&gt;</code>路径名</li>
<li><code>Secure</code>一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器</li>
<li><code>HttpOnly</code>设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由  Document.cookie 属性、XMLHttpRequest 和  Request APIs 进行访问，以防范跨站脚本攻击（XSS）</li>
<li><code>SameSite</code>允许服务器设定一则 cookie 不随着跨域请求一起发送</li>
</ul>
<p>实例：</p>
<pre><code class="language-js">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre>
<h2 id="express依赖项研究">Express依赖项研究</h2>
<h4 id="cookie"><code>cookie</code></h4>
<p>这个库主要是用来解析或者序列化cookie的信息的，API也只有两个一个是<code>cookie.parse(str, options)</code>，它的options只有一个选项<code>decode</code>用来规定采用何种解码方法，一个是<code>cookie.serialize(name, value, options)</code>它的options和<code>set-cookie</code>的可选项一致。</p>
<h4 id="cookie-signature"><code>cookie-signature</code></h4>
<p>使用Nodejs自带的crypto模块签名和解析签名过的cookie，使用方法:</p>
<pre><code class="language-js">var cookie = require('cookie-signature');
var val = cookie.sign('hello', 'tobiiscool');
val.should.equal('hello.DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI');
var val = cookie.sign('hello', 'tobiiscool');
cookie.unsign(val, 'tobiiscool').should.equal('hello');
cookie.unsign(val, 'luna').should.be.false;
</code></pre>
<h4 id="cookie-parser"><code>cookie-parser</code></h4>
<p><code>cookie-parser</code>依赖了<code>cookie</code>和<code>cookie-signature</code>，如果用户在调用的时候传入了<code>secret</code>的话，则会生成signedCookie，否则为普通的json的cookie的键值对。</p>
<p>使用方法：</p>
<pre><code class="language-js">var express = require('express')
var cookieParser = require('cookie-parser')
var app = express()
app.use(cookieParser())
</code></pre>
<p>API:</p>
<ul>
<li><code>cookieParser(secret, options)</code><br>
<code>secret</code>可以为数组或者字符串，options等同于<code>cookie.parse</code>传入的可选项</li>
<li><code>cookieParser.JSONCookie(str)</code><br>
将字符串解析为json形式</li>
<li><code>cookieParser.JSONCookies(cookies)</code><br>
将给定对象重复使用JSONCookie将value值替换为解析值</li>
<li><code>cookieParser.signedCookie(str, secret)</code><br>
解析signedCookie值</li>
<li><code>cookieParser.signedCookies(cookies, secret)</code><br>
将给定的对象重读使用signedCookie将value值替换为解析值</li>
</ul>
<h4 id="express-session"><code>express-session</code></h4>
<p>这个中间件将session保存在服务端，将对应的session ID保存在cookie中，默认地是将session保存在内存中，不能在生产环境中使用，会引起内存泄漏，可以选择使用<code>session-store</code>将之存储在数据库中。使用方法：</p>
<pre><code class="language-js">var session = require('express-session')
var express = require('express')
var app = express()
app.use(session({
    secret:&quot;huxinmin&quot;, //签名使用
    cookie:{  //&quot;参照cookie中的设置&quot;,
        domain:
        expires:
        httpOnly:
        maxAge:
        path:
        sameSite:
        secure:
    },
    genid:function(req){ //生成session ID的方法，默认使用uid-safe

    },
    name:&quot;&quot;, //session ID的名字，默认是connect.sid
    proxy:undefined, //当设置了cookies secure选项时，信任的代理服务器
    resave:true, //强制保存session到session store即使没有任何改变
    rolling:false, //强制在每一次responce时重新设置cookie的识别符，例如maxAge
    saveUninitialized:true, //是否自动保存未初始化的会话
    store: new MemoryStore(), //session存储的实例
    unset：'keep', //响应结束后是否保存存储的session  
}))
</code></pre>
<p>创建成功后，就可以在<code>req.session</code>中访问到session了，同时它上面还有如下这些方法或属性：</p>
<ul>
<li>regenerate(callback)重新生成session</li>
<li>destroy(callback)销毁</li>
<li>reload(callback)重载</li>
<li>save(callback)将session保存至store中</li>
<li>touch()更新<code>.maxAge</code>属性</li>
<li>id session ID的别名，req.sessionID中保存的是session ID</li>
<li>cookie伴随session的cookie</li>
</ul>
<p>除了这些，你还可以自定义你自己的属性或方法，只要挂载到<code>req.session</code>上即可。</p>
<h4 id="cookie-session"><code>cookie-session</code></h4>
<p>这个插件会将session的信息存储在cookie中，不过不能超过4KB大小。</p>
<p>使用方法：</p>
<pre><code class="language-js">var cookieSession = require('cookie-session')
var express = require('express')
var app = express()
app.use(cookieSession({
  name: 'session',
  keys: [/* secret keys */], //或者使用字符串的scret:&quot;&quot;
  // Cookie 选项，除了包含常见的expires，path，domain，等还包括signed和overwrite
  maxAge: 24 * 60 * 60 * 1000, // 24 hours
  signed:true,//是否签名的cookie
  overwrite:true //设置cookie之前是否重写
}))
</code></pre>
<p>然后你就能在<code>req.session</code>中访问到了创建的<code>session</code>，并且还有下面几个属性：</p>
<ul>
<li><code>req.sessionOptions.isChanged</code>判断session是否变化</li>
<li><code>req.sessionOptions.isNew</code>判断session是否是新的</li>
<li><code>req.sessionOptions.isPopulated</code>判断session是否有填充数据</li>
<li><code>req.sessionOptions</code>创建session时的选项的一个浅拷贝</li>
<li><code>req.session = null</code>可以销毁session</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://github.com/expressjs/cookie-parser" target="_blank" rel="nofollow">cookie-parser</a></li>
<li><a href="https://github.com/expressjs/cookie-session" target="_blank" rel="nofollow">cookie-session</a></li>
<li><a href="https://github.com/expressjs/session" target="_blank" rel="nofollow">express-session</a></li>
<li><a href="https://github.com/jshttp/cookie" target="_blank" rel="nofollow">cookie</a></li>
<li><a href="https://github.com/tj/node-cookie-signature" target="_blank" rel="nofollow">cookie-signature</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="nofollow">MDN http cookies</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="nofollow">MDN set-cookie</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" target="_blank" rel="nofollow">MDN document.cookie</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用JS判断当前页面是否打开或者切换标签]]></title>
        <id>https://huxinmin.github.io/post/shi-yong-js-pan-duan-dang-qian-ye-mian-shi-fou-da-kai-huo-zhe-qie-huan-biao-qian/</id>
        <link href="https://huxinmin.github.io/post/shi-yong-js-pan-duan-dang-qian-ye-mian-shi-fou-da-kai-huo-zhe-qie-huan-biao-qian/">
        </link>
        <updated>2020-04-20T07:33:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>对于页面上的有些事件，例如动画，需要在页面切换的时候暂停，切换回来的时候恢复，或者一些提示消息，需要在页面处在激活状态的时候取消提示，切换的时候才显示提示消息，我们就需要监听页面的切换标签页或者失去焦点的事件。</p>
<h2 id="传统做法">传统做法</h2>
<p>一般只需要监听页面的聚焦和失焦的事件就可以了：</p>
<pre><code class="language-js">window.onfocus = function() {
    isShine = false;
};
window.onblur = function() {
    isShine = true;
};
// for IE
document.onfocusin = function() {
    isShine = false;
};
document.onfocusout = function() {
    isShine = true;
};
</code></pre>
<p>但是经过我自己实际测试，这个方法并不能很好的检测页面的切换事件，有时候会出现没有响应的情况，那么有没有更好的方法来检测页面的切换事件呢？我们可以使用H5的<code>visibilitychange</code>和<code>document.hidden</code>来进行判断即可。</p>
<h2 id="使用">使用</h2>
<p>因为不同的浏览器的<code>visibilitychange</code>的名称可能不一样，所以我们首先来获取一下当前浏览器支持的<code>visibilitychange</code>的名称：</p>
<pre><code class="language-js">var stateKey, 
    eventKey, 
    keys = {
        hidden: &quot;visibilitychange&quot;,
        webkitHidden: &quot;webkitvisibilitychange&quot;,
        mozHidden: &quot;mozvisibilitychange&quot;,
        msHidden: &quot;msvisibilitychange&quot;
    };
    for (stateKey in keys) {
        if (stateKey in document) {
            eventKey = keys[stateKey];
            break;
        }
    }
</code></pre>
<p>同理，你还需要获取当前浏览器的<code>document.hidden</code>的名称，在循环代码中加入：</p>
<pre><code class="language-js">    var propertyKey = &quot;&quot;;
    for (stateKey in keys) {
        if (stateKey in document) {
            propertyKey =  stateKey ;
            eventKey = keys[stateKey];
            break;
        }
    }
</code></pre>
<p>最后只需要添加事件监听即可：</p>
<pre><code class="language-js">document.addEventListener(eventKey, function(){
    //如果是聚焦
    if(!document[propertyKey]){
    //你的代码
    }else{
    //你的代码
    }
});
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="nofollow">MDN</a></li>
<li><a href="https://mokiee.com/code/193" target="_blank" rel="nofollow">js判断当前页面是否失去焦点(切换标签页)</a></li>
<li><a href="https://greensock.com/forums/topic/9059-cross-browser-to-detect-tab-or-window-is-active-so-animations-stay-in-sync-using-html5-visibility-api/" target="_blank" rel="nofollow">Cross browser to detect tab or window is active so animations stay in sync using HTML5 Visibility API</a></li>
</ul>
]]></content>
    </entry>
</feed>